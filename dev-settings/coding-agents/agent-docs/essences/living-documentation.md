# Living Documentation — エッセンス

## 関連URL

- Living Documentation
  - 公式サイト: <https://leanpub.com/livingdocumentation>
  - O'Reilly: <https://learning.oreilly.com/library/view/living-documentation-continuous/9780134689418/>

---

## Living Documentationとは何か

> *"You don't have to choose between working software and extensive documentation!"*

コードと同じペースで進化するドキュメント。書いた瞬間から陳腐化する従来のドキュメントではなく、**コードの変更が自動的にドキュメントに反映される**仕組みを作ること。

**ソフトウェア開発は本質的に知識管理の問題**:

- 開発者の離職率の半減期は **3.1年**、コードの半減期は **13年**
- 開発コストの大部分は「理解」に費やされる
- 「動くソフトウェア」か「十分なドキュメント」か、という二項対立は誤り

---

## 従来のドキュメントの失敗パターン

| アンチパターン | 内容 |
| --- | --- |
| **分離された活動** | 設計・実装・テスト・ドキュメントが別工程になり知識が重複・乖離 |
| **手動トランスクリプション** | コードの内容を別のドキュメントに手書きで写す（写字生作業） |
| **冗長な知識** | コードとドキュメントの2箇所に同じ知識が存在し、片方が腐る |
| **情報の墓場** | 企業Wiki・SharePoint・共有フォルダに書かれ二度と読まれない |
| **ブレインダンプ** | 誰にとっても役に立たない無秩序な思考の書き出し |

**根本原因**: ドキュメントが「別の作業」として扱われているため、コードと乖離する。

---

## 4つのコア特性

| 特性 | 定義 |
| --- | --- |
| **Reliable（信頼性）** | 常に現在のコードと同期している |
| **Low-effort（低負荷）** | 変更時の追加作業を最小化する |
| **Collaborative（協調性）** | 全関係者間の会話と知識共有を促進する |
| **Insightful（洞察力）** | フィードバックと深い思考の機会を提供する |

---

## 知識管理の2つのアプローチ

### Knowledge Exploitation（知識の活用）

**ほとんどの知識はすでにコードの中に存在している。**

コードは既にHow（何をするか）を語っている。問題は、その知識が以下の状態にあること：

- **アクセス不可**: 非技術者が読めない
- **豊富すぎる**: 詳細が多すぎて有用でない
- **断片化している**: 複数箇所に分散
- **暗黙的**: 明文化されていない

→ 既存の知識を抽出・変換して利用可能にすることが第一歩。

### Knowledge Augmentation（知識の拡張）

**コードだけでは完全なストーリーを語れない。**

> *"Design is as much the decisions and the reasons as the results of the decisions."* — Ralph Johnson

橋の比喩: 技術図面は寸法を示すが、**なぜその寸法を選んだか**（材料強度計算・想定した極端条件）は示さない。コードが変更されるときに必要なのは「理由」の知識。

プログラミング言語が表現できないものを補完する手段:

| 手段 | 特徴 |
| --- | --- |
| **アノテーション**（Java/C#） | 構造化・リファクタリング耐性・IDEで検索可能 |
| **命名規則** | パッケージ名・クラス名でドメイン知識を表現 |
| **サイドカーファイル** | コードを変更せずに外部から知識を付加 |
| **DSL** | ドメイン固有言語で意図を表現 |

**アノテーションの強み**: 要素がリネームされても追従し、削除されると一緒に消える（= リファクタリング耐性）。

---

## 中核原則：Document the Why, Not the What

```text
コード     → How（どうやって実装するか）
テスト     → What（何のビジネスルールを見たいか）
コミットログ → Why（なぜそうしたのか）
```

**コードは「何をするか」を語る。「なぜそうするか」は別に記録しなければならない。**

### コードコメントへの適用

**コードコメントは原則として書かない。** コードが How を、テストが What を語れるよう書くことが目標。

書く場合は **Why not（選択しなかった理由）** を最優先とする。

| 優先度 | 種類 | 説明 |
| --- | --- | --- |
| **最優先** | Why not | 改善できたが敢えてしなかった理由 |
| **補助** | Why | 複雑なロジックの背景（コードから推測困難な場合のみ） |
| **避ける** | What | コード自体が語るべき内容 |

**Why not が最も価値が高い理由**: Why は実装を見れば推測できるが、Why not（選択しなかった理由）は実装からは絶対に見えない。

```go
// Good: Why not を記述
// N+1問題が存在するが、データ量が300件程度のため
// JOIN最適化は実装していない。1000件を超える場合は要検討。
func GetUsers() []User { ... }
```

**Coding Agent のルール**:

- ユーザーが明示的に許可した場合のみ記述する
- Why not を表しているか確認する
- Why not は意図的な判断を伴うため**人間が書くべき**（AI が生成するコメントは Why になりがち）

詳細・実践例: `dev-settings/coding-agents/agent-docs/conventions/code-comments.md`

### コミットメッセージへの適用

コミットログが「なぜ変更したか（Why）」を残す唯一の場所。

**Conventional Commits フォーマット**（日本語・UTF-8 必須）:

```text
<type>: <subject（命令形・50文字以内）>

<body: WHY を記述・72文字で改行>
```

主要 type: `feat` / `fix` / `docs` / `refactor` / `tidy` / `test` / `chore`

```text
feat: ユーザー登録時のメールアドレス検証を追加

重複登録を防ぐため、メールアドレスの一意性チェックを実装。
```

**TDD 時のコミット分離**: `test:（失敗）→ feat:（最小実装）→ refactor:（整理）` の3コミットに分ける。

詳細・実践例: `dev-settings/coding-agents/agent-docs/conventions/commit-messages.md`

---

## 主要パターン

### Single Source of Truth（唯一の真実の源）

知識は一箇所にのみ存在する。コピーは自動生成（公開メカニズム）で行う。

- コード変更 → ドキュメントが自動再生成される仕組みを作る
- 手動同期を必要とする冗長コピーを排除する

### Living Glossary（生きた用語集）

コードのパッケージ名・クラス名からドメイン用語集を自動生成。

- **DDD のユビキタス言語**の実装
- 「用語集を修正したい」→ まずコードを修正 → ビルドで用語集が更新される
- ビジネス担当者が命名の混乱に気づくきっかけになる

### Living Diagrams（生きた図）

コードから依存関係図・アーキテクチャ図を自動生成（Graphviz 等）。

- 手書き図は常に陳腐化する。自動生成図は常に現在の状態を反映
- **精神的なビューと生成されたビューを比較することで設計の弱点を発見できる**

### BDD / Gherkin によるリビング仕様

```gherkin
In order to 顧客維持率を高めるために
As a マーケティング担当者として
I want to 最近の忠実な顧客に割引を提供したい

Scenario: 最近の忠実な顧客に次回の購入で10ドル割引
  Given ...
  When ...
  Then ...
```

- シナリオは**自動テスト**に昇格させる（テストが失敗 = 仕様とコードのズレを即検出）
- タグで動的キュレーション（`@keyexample`, `@acceptancecriteria` 等）
- 非技術者がブラウザで検索・閲覧できる形式（Pickles、Tzatziki 等で生成）

### Architecture Decision Records（ADR）

設計決定とその根拠を構造化して記録。

```markdown
## Status: accepted

## Context
なぜこの問題に直面したか

## Decision
何を選択したか

## Consequences
その結果どうなるか（良い面・悪い面）
```

- **コメントより構造化された形式**を使う（コメントはリファクタリングに追従しない）
- ADRは「過去の意思決定のWhy」を将来の開発者に伝える

### Stable vs Volatile Knowledge

| 分類 | 内容 | 対応 |
| --- | --- | --- |
| **Stable（安定）** | ビジョン・高レベル要件・ドメイン用語 | 従来の文書化でも可（Word・Wiki・PDF） |
| **Volatile（変化）** | 設計決定・実装詳細・低レベル振る舞い | 自動生成・リファクタリング耐性が必須 |

**Evergreen Documents の条件**: 短い・高レベル・ビジネス中心・変化しない内容のみ記述。

### Highlighted Core（ドメインコアの強調）

重要なドメイン概念をアノテーションや命名で明示する。

```java
@CoreConcept
public class Order { ... }

@DomainService
public class PricingPolicy { ... }
```

- IDEの検索でドメインモデルの全体像を把握できる
- 新規参加者のオンボーディングが速くなる

### Exemplar（見本）

模範的な実装例にアノテーションを付与。

```java
@Exemplar
public class OrderImporterTest { ... }
```

- 「どう書けばよいか」の公式な見本を明示
- 全員が模倣することで品質が底上げされる

---

## 自動化の3つのメカニズム

| メカニズム | 説明 | 例 |
| --- | --- | --- |
| **Extraction（抽出）** | ソースコードから知識を自動抽出 | Javadoc、Cucumber レポート |
| **Propagation（伝播）** | 変更を関連する場所に自動伝播 | IDEのリネームで全参照更新 |
| **Reconciliation（照合）** | 冗長な情報間の一貫性を自動検証 | BDD シナリオ↔コードの整合性テスト |

**優先順位**: コードに近い知識から自動化する。コードから離れた知識は Stable Document として管理。

---

## レガシーシステムへの適用

### Documentation Bankruptcy

レガシーシステムの仕様は「化石化した知識」。失われた仕様はシステム自体から逆算する。

**Bubble Context（泡のコンテキスト）**: レガシー内に理想的な小さな島を作る。

- 新しい領域でTDD/BDD/DDDを実践
- **Strangler Application パターン**で段階的に置き換え

### External Annotations

コードに手を入れずに外部ファイルで知識を付加する。

```yaml
# package_mapping.yml
com.example.orders: "注文処理ドメイン"
com.example.billing: "請求ドメイン"
```

### Biodegradable Transformation（生分解性の変革）

一時的な変革情報は完了時に消えるべき。

```java
@StrangledBy(NewOrderService.class)  // 置き換え中
@Bankrupt  // 変更禁止マーク
```

---

## コントロールドボキャブラリー（統制語彙）

チーム全体で使う用語を統一する。DDD の「ユビキタス言語」が実装に近い。

- **小規模**: README にグロッサリーを追加
- **理想**: コードの命名 = ビジネス用語（用語集がコードから自動生成される）

---

## 実践への導入

### 小さく始める

1. **コミットメッセージに Why を書く習慣から始める**（コスト最小・効果大）
2. テスト名を日本語でビジネスルールを表現する
3. 重要な設計判断に ADR を1つ書く
4. 既存の命名をドメイン用語に近づけるリネームを行う

### コードレビューでの活用

- 「このコードが何をするか」ではなく「なぜこの設計にしたか」を確認する
- 命名がビジネス用語を反映しているかを確認する
- 設計意図がコードから読み取れるかを確認する

### 判断基準

| 問い | 答えがNOなら |
| --- | --- |
| このドキュメントはコード変更時に自動更新されるか？ | 自動化を検討する |
| この情報はコードを見れば分かるか？ | ドキュメントを削除する |
| なぜこの決定をしたかがコードから分かるか？ | ADR またはコミットログに記録する |
| この知識は6ヶ月後も変わらないか？ | Stable Document として記録する |
