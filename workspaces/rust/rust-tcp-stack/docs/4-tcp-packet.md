# Phase 4: TCPパケットパーサー（TDDで）

## このフェーズで学ぶこと

このフェーズでは、TCPプロトコルの構造と役割について学びます。具体的には、SYN、ACK、FINなどのフラグの扱い方を習得し、疑似ヘッダーを使ったチェックサム計算の実装方法を理解します。また、3-wayハンドシェイクの仕組みを学びます。

---

## TCPとは？

TCP（Transmission Control Protocol）は、トランスポート層で使用されるプロトコルで、信頼性のあるデータ転送を実現します。

### TCPの主な特徴

1. コネクション型: 通信前に接続を確立
2. 信頼性: データの到達を保証（再送制御）
3. 順序保証: パケットの順序を保証
4. フロー制御: 受信側の処理能力に応じて送信速度を調整
5. 輻輳制御: ネットワークの混雑を回避

UDPとの違い。

- TCP: 信頼性重視、オーバーヘッドあり（Web、メール、ファイル転送等）
- UDP: 速度重視、オーバーヘッド小（動画ストリーミング、ゲーム等）

---

## TCPセグメントの構造

```text
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (可変長)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 主要フィールド

1. Source Port（16ビット）: 送信元ポート番号
2. Destination Port（16ビット）: 宛先ポート番号
3. Sequence Number（32ビット）: データの位置を示す番号
4. Acknowledgment Number（32ビット）: 次に受信したいデータの位置
5. Data Offset（4ビット）: ヘッダー長（32ビットワード単位、最小値5 = 20バイト）
6. Flags（6ビット）: 制御フラグ（SYN、ACK、FIN等）
7. Window（16ビット）: 受信可能なデータ量（フロー制御）
8. Checksum（16ビット）: データの整合性確認

---

## ポート番号とは？

ポート番号は、1台のコンピュータ内でどのアプリケーションが通信するかを識別するための番号です。

### ポート番号の範囲

| 範囲 | 分類 | 用途 |
|------|------|------|
| 0〜1023 | ウェルノウンポート | 標準的なサービス（HTTP:80, HTTPS:443, SSH:22等） |
| 1024〜49151 | 登録済みポート | 特定のアプリケーション |
| 49152〜65535 | 動的ポート | クライアントが一時的に使用 |

例：Webブラウザ（ポート49152）→ Webサーバー（ポート80）

---

## TCPフラグ

TCPフラグは、接続の制御に使用されます。

| フラグ | 名前 | 意味 |
|--------|------|------|
| SYN | Synchronize | 接続確立の開始 |
| ACK | Acknowledgment | 確認応答 |
| FIN | Finish | 接続終了 |
| RST | Reset | 接続リセット |
| PSH | Push | データを即座に送信 |
| URG | Urgent | 緊急データ |

---

## 3-wayハンドシェイク

TCPは接続確立時に3-wayハンドシェイクを行います。

```text
クライアント                        サーバー
    |                                  |
    |  (1) SYN (Seq=100)               |
    |--------------------------------->|
    |                                  |
    |  (2) SYN-ACK (Seq=200, Ack=101)  |
    |<---------------------------------|
    |                                  |
    |  (3) ACK (Seq=101, Ack=201)      |
    |--------------------------------->|
    |                                  |
    |        接続確立完了               |
```

1. SYN: クライアントが接続要求（SYNフラグをセット）
2. SYN-ACK: サーバーが接続受諾（SYNとACKフラグをセット）
3. ACK: クライアントが確認応答（ACKフラグをセット）

---

## 疑似ヘッダーとは？

TCPのチェックサムは、TCPヘッダーとデータだけでなく、疑似ヘッダーも含めて計算します。疑似ヘッダーは、IPヘッダーの一部情報を含み、パケットが正しい宛先に届いたかを検証します。

```text
+--------+--------+--------+--------+
|           Source Address          |  (IPv4から)
+--------+--------+--------+--------+
|        Destination Address        |  (IPv4から)
+--------+--------+--------+--------+
|  zero  |  PTCL  |    TCP Length   |
+--------+--------+--------+--------+
```

---

## TODOリスト（Phase 4）

```text
TCPパケットパーサー
□ 20バイト未満のデータは拒否する
□ 20バイト以上のデータは受け入れる
□ 送信元ポート番号を取得できる
□ 宛先ポート番号を取得できる
□ シーケンス番号を取得できる
□ 確認応答番号を取得できる
□ SYNフラグを判定できる
□ ACKフラグを判定できる
□ FINフラグを判定できる
□ ウィンドウサイズを取得できる
□ ペイロードを取得できる
□ チェックサムを計算できる（疑似ヘッダー含む）
```

---

## モジュールのセットアップ

`src/tcp.rs`を作成します。

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tcpパケットは20バイト未満を拒否する() {
        let short_data = [0u8; 19];
        assert!(TcpPacket::new(&short_data).is_none());
    }
}
```

重要: モジュール宣言を忘れずに！

### ライブラリプロジェクトの場合（src/lib.rs）

```rust
pub mod ethernet;
pub mod ipv4;
pub mod tcp;
```

### バイナリプロジェクトの場合（src/main.rs）

```rust
mod ethernet;
mod ipv4;
mod tcp;

fn main() {
    println!("Hello, world!");
}
```

---

## Iteration 16-20: 基本的なパーサー実装

### 構造体とnewメソッド

まず、TCPパケットを表現する構造体を定義します。この構造体は、バイト列からTCPヘッダーの情報を読み取るための「窓」のような役割を果たします。

```rust
pub struct TcpPacket<'a> {
    data: &'a [u8],
}

impl<'a> TcpPacket<'a> {
    pub fn new(data: &'a [u8]) -> Option<Self> {
        if data.len() < 20 {
            return None;
        }
        Some(TcpPacket { data })
    }
}
```

#### なぜこのコードを書くのか？

このコードには、いくつかの重要な設計上の判断が含まれています。順番に見ていきましょう。

#### 1. ライフタイムパラメータ`'a`とは何か

`TcpPacket<'a>`の`'a`は「ライフタイム」と呼ばれるものです。これは「この参照がどれだけの期間有効か」をRustコンパイラに伝えるための印です。

具体的には、`TcpPacket`は元のバイト列への参照（`&'a [u8]`）を保持しています。この`'a`は「`TcpPacket`が生きている間、元のバイト列も生きていることを保証してください」という意味です。

これにより、以下のような危険な状況を防ぐことができます。

```rust
// これはコンパイルエラーになる（安全！）
let packet = {
    let data = vec![0u8; 20];
    TcpPacket::new(&data).unwrap()
}; // dataがここでドロップされる
// packetはdataへの参照を持っているが、dataはもう存在しない！
```

Rustのライフタイムシステムは、このような「参照先が消えてしまった参照」を持つことを許しません。

#### 2. なぜバイト列の参照を保持するのか

`TcpPacket`は、バイト列のコピーではなく参照を保持しています。これには2つの利点があります。

- 効率性: 大きなパケット（最大65KB以上）をコピーする必要がありません。参照は常にポインタサイズ（8バイトまたは16バイト）だけです。
- ゼロコピー: 元のバイト列をそのまま使うことで、メモリの無駄遣いを防ぎます。

この設計を「ゼロコピーパーサー」と呼び、高性能なネットワークプログラミングでよく使われる手法です。

#### 3. なぜ20バイトをチェックするのか

TCPヘッダーは最小で20バイトです。この20バイトには、以下の必須情報が含まれています。

```text
0-1バイト:   送信元ポート番号
2-3バイト:   宛先ポート番号
4-7バイト:   シーケンス番号
8-11バイト:  確認応答番号
12バイト:    データオフセット + 予約ビット
13バイト:    フラグ（SYN、ACK等）
14-15バイト: ウィンドウサイズ
16-17バイト: チェックサム
18-19バイト: 緊急ポインタ
```

20バイト未満のデータは、これらの必須フィールドが含まれていないため、不正なTCPパケットです。`new`メソッドでこのチェックを行うことで、後続のメソッドで安全にバイト列にアクセスできます。

#### 4. なぜOption型を返すのか

`new`メソッドは`Option<Self>`を返します。これは以下の2つの可能性を表現しています。

- `Some(TcpPacket { data })`: パース成功（20バイト以上ある）
- `None`: パース失敗（20バイト未満、または他の検証失敗）

Rustでは、失敗する可能性のある操作に`Option`や`Result`を使うことで、エラーハンドリングを型システムで強制します。これにより、呼び出し側が失敗の可能性を無視できないようになっています。

例えば、以下のように使います。

```rust
match TcpPacket::new(&data) {
    Some(packet) => println!("パース成功: ポート {}", packet.source_port()),
    None => println!("パース失敗: データが短すぎます"),
}
```

### ポート番号の取得

次に、TCPヘッダーからポート番号を読み取るメソッドを実装します。ポート番号は、1台のコンピュータ内でどのアプリケーションが通信するかを識別するための番号でしたね。

#### テスト

```rust
#[test]
fn 送信元ポート番号を取得できる() {
    let mut data = [0u8; 20];
    data[0] = 0x00;
    data[1] = 0x50; // ポート80 (HTTP)

    let packet = TcpPacket::new(&data).unwrap();
    assert_eq!(packet.source_port(), 80);
}

#[test]
fn 宛先ポート番号を取得できる() {
    let mut data = [0u8; 20];
    data[2] = 0x1f;
    data[3] = 0x90; // ポート8080

    let packet = TcpPacket::new(&data).unwrap();
    assert_eq!(packet.destination_port(), 8080);
}
```

#### 実装

```rust
impl<'a> TcpPacket<'a> {
    pub fn source_port(&self) -> u16 {
        u16::from_be_bytes([self.data[0], self.data[1]])
    }

    pub fn destination_port(&self) -> u16 {
        u16::from_be_bytes([self.data[2], self.data[3]])
    }
}
```

#### なぜこのコードを書くのか？

#### 1. TCPヘッダーにおけるポート番号の位置

TCPヘッダーの仕様により、ポート番号は以下の位置に配置されています。

- 送信元ポート: 0-1バイト目（最初の2バイト）
- 宛先ポート: 2-3バイト目（次の2バイト）

これはTCP/IPの標準仕様（RFC 793）で定められており、世界中のすべてのTCP実装で共通です。私たちの実装も、この仕様に従ってバイト列を読み取る必要があります。

#### 2. ビッグエンディアンとは何か

ネットワークプロトコルでは、2バイト以上の数値を送信する際に「ビッグエンディアン」という形式を使います。これは「大きい桁（上位バイト）を先に送る」という規則です。

例えば、ポート番号80（10進数）を送信する場合。

```text
80（10進数）= 0x0050（16進数）

ビッグエンディアンでの並び:
data[0] = 0x00  ← 上位バイト（大きい桁）
data[1] = 0x50  ← 下位バイト（小さい桁）
```

もし8080（10進数）の場合。

```text
8080（10進数）= 0x1F90（16進数）

ビッグエンディアンでの並び:
data[2] = 0x1F  ← 上位バイト
data[3] = 0x90  ← 下位バイト
```

ビッグエンディアンは「ネットワークバイトオーダー」とも呼ばれ、インターネット上のすべての通信で使われる標準形式です。

#### 3. `u16::from_be_bytes`の役割

`u16::from_be_bytes([byte1, byte2])`は、2つのバイトをビッグエンディアン形式で解釈し、`u16`型（16ビット符号なし整数）に変換する関数です。

具体的な動作。

```rust
// 例1: ポート80
u16::from_be_bytes([0x00, 0x50])
// → (0x00 << 8) | 0x50
// → 0x0000 | 0x0050
// → 0x0050
// → 80（10進数）

// 例2: ポート8080
u16::from_be_bytes([0x1F, 0x90])
// → (0x1F << 8) | 0x90
// → 0x1F00 | 0x0090
// → 0x1F90
// → 8080（10進数）
```

この関数は、バイト配列から数値への変換を安全かつ明確に行うために、Rustの標準ライブラリで提供されています。

#### 4. なぜインデックスアクセスが安全なのか

`self.data[0]`や`self.data[1]`といったインデックスアクセスは、通常は範囲外アクセスの危険性があります。しかし、ここでは安全です。なぜなら。

- `new`メソッドで`data.len() < 20`をチェック済み
- つまり、`TcpPacket`が存在する時点で、`data`は必ず20バイト以上ある
- したがって、`data[0]`～`data[19]`へのアクセスは常に安全

このように、コンストラクタで事前条件をチェックすることで、後続のメソッドでは安全にデータにアクセスできるようになります。この設計パターンを「不変条件（invariant）の維持」と呼びます。

---

## Iteration 21-23: シーケンス番号と確認応答番号

次に、TCPの信頼性を支える重要な2つのフィールド、シーケンス番号と確認応答番号を実装します。これらは、データが正しく、順序通りに届くことを保証するための仕組みです。

### テスト

```rust
#[test]
fn シーケンス番号を取得できる() {
    let mut data = [0u8; 20];
    data[4..8].copy_from_slice(&[0x00, 0x00, 0x00, 0x64]); // 100

    let packet = TcpPacket::new(&data).unwrap();
    assert_eq!(packet.sequence_number(), 100);
}

#[test]
fn 確認応答番号を取得できる() {
    let mut data = [0u8; 20];
    data[8..12].copy_from_slice(&[0x00, 0x00, 0x00, 0xc9]); // 201

    let packet = TcpPacket::new(&data).unwrap();
    assert_eq!(packet.acknowledgment_number(), 201);
}
```

### 実装

```rust
impl<'a> TcpPacket<'a> {
    pub fn sequence_number(&self) -> u32 {
        u32::from_be_bytes([
            self.data[4],
            self.data[5],
            self.data[6],
            self.data[7],
        ])
    }

    pub fn acknowledgment_number(&self) -> u32 {
        u32::from_be_bytes([
            self.data[8],
            self.data[9],
            self.data[10],
            self.data[11],
        ])
    }
}
```

### なぜこのコードを書くのか？

#### 1. シーケンス番号と確認応答番号の役割

TCPは「信頼性のある」通信プロトコルです。つまり、送信したデータが確実に相手に届き、しかも正しい順序で届くことを保証します。この保証を実現するのが、シーケンス番号と確認応答番号です。

シーケンス番号（Sequence Number）は、送信するデータの位置を示す番号です。例えば。

```text
送信側の動作:
- 1回目: "Hello"を送信、シーケンス番号 = 100
- 2回目: "World"を送信、シーケンス番号 = 105 (100 + "Hello"の5バイト)
- 3回目: "!"を送信、シーケンス番号 = 110 (105 + "World"の5バイト)
```

確認応答番号（Acknowledgment Number）は、「次に受信したいデータの位置」を示す番号です。例えば。

```text
受信側の動作:
- "Hello"（シーケンス番号100）を受信
  → 確認応答番号 = 105を返す（「105番から送ってください」という意味）
- "World"（シーケンス番号105）を受信
  → 確認応答番号 = 110を返す（「110番から送ってください」という意味）
```

この仕組みにより、以下が可能になります。

- 順序保証: パケットが順不同に届いても、シーケンス番号で正しい順序に並べ替えられる
- 重複検出: 同じシーケンス番号のパケットが2回届いたら、2回目は破棄できる
- 欠落検出: シーケンス番号が飛んでいたら、パケットが失われたことが分かる
- 再送制御: 確認応答が返ってこないパケットは、自動的に再送される

#### 2. なぜ32ビット（4バイト）なのか

シーケンス番号と確認応答番号は、どちらも32ビット（4バイト）の整数です。これは、以下の理由があります。

- 範囲の広さ: 32ビットで0〜4,294,967,295（約43億）の値を表現できる
- 十分な大きさ: 高速なネットワークでも、番号が一周する前に古いパケットは破棄される
- 標準化: TCP/IPの仕様（RFC 793）で定められた標準サイズ

ポート番号が16ビット（2バイト）だったのに対し、シーケンス番号は倍の32ビットです。これは、シーケンス番号が送信するデータ量に応じて増え続けるため、より大きな範囲が必要だからです。

#### 3. TCPヘッダーにおける位置

TCPヘッダーの仕様により、これらの番号は以下の位置に配置されています。

```text
0-3バイト:   送信元ポート番号（2バイト）+ 宛先ポート番号（2バイト）
4-7バイト:   シーケンス番号（4バイト）      ← ここ
8-11バイト:  確認応答番号（4バイト）        ← ここ
12バイト以降: その他のフィールド
```

- シーケンス番号: 4-7バイト目（4バイト）
- 確認応答番号: 8-11バイト目（4バイト）

#### 4. `u32::from_be_bytes`の使い方

ポート番号の時は`u16::from_be_bytes`を使いましたが、ここでは`u32::from_be_bytes`を使います。これは、32ビット整数をビッグエンディアン形式で読み取るための関数です。

具体的な動作を見てみましょう。

```rust
// シーケンス番号 = 100 の場合
// 100（10進数）= 0x00000064（16進数、32ビット）

// ビッグエンディアンでの並び:
data[4] = 0x00  // 最上位バイト
data[5] = 0x00
data[6] = 0x00
data[7] = 0x64  // 最下位バイト

// u32::from_be_bytesで変換:
u32::from_be_bytes([0x00, 0x00, 0x00, 0x64])
// → (0x00 << 24) | (0x00 << 16) | (0x00 << 8) | 0x64
// → 0x00000000 | 0x00000000 | 0x00000000 | 0x00000064
// → 0x00000064
// → 100（10進数）
```

もう少し大きな数の例も見てみましょう。

```rust
// 確認応答番号 = 201 の場合
// 201（10進数）= 0x000000C9（16進数）

data[8]  = 0x00
data[9]  = 0x00
data[10] = 0x00
data[11] = 0xC9

u32::from_be_bytes([0x00, 0x00, 0x00, 0xC9])
// → 201（10進数）
```

#### 5. 配列スライスの範囲指定

テストコードで`data[4..8].copy_from_slice(&[0x00, 0x00, 0x00, 0x64])`という記法を使っています。これは、配列の一部分（スライス）にデータをコピーする方法です。

```rust
data[4..8]  // 4バイト目から8バイト目の手前まで（4, 5, 6, 7の4バイト）
```

Rustの範囲指定は「開始位置は含む、終了位置は含まない」という規則なので、`4..8`は「4, 5, 6, 7」を意味します。

実装コードでは、この4つのバイトを個別に指定しています。

```rust
[self.data[4], self.data[5], self.data[6], self.data[7]]
```

これらは同じ4バイトを指していますが、実装では配列リテラルの形式で`u32::from_be_bytes`に渡しています。

#### 6. TCPの信頼性の実現

これらのフィールドを使って、TCPは以下のような動作を実現します。

```text
【正常な通信の例】
クライアント                          サーバー
    |                                    |
    | Seq=100, データ="Hello"           |
    |----------------------------------->|
    |                                    | データを受信
    |           Ack=105（次は105から）   |
    |<-----------------------------------|
    |                                    |
    | Seq=105, データ="World"           |
    |----------------------------------->|
    |                                    |

【パケット欠落の例】
クライアント                          サーバー
    |                                    |
    | Seq=100, データ="Hello"           |
    |----------------------------------->|
    |                                    |
    | Seq=105, データ="World"           |
    |------------- X （途中で消失）      |
    |                                    |
    | Seq=110, データ="!"               |
    |----------------------------------->|
    |                                    | Seq=110が届いたが、
    |                                    | 105が欠けていることに気づく
    |           Ack=105（105を再送して） |
    |<-----------------------------------|
    |                                    |
    | Seq=105, データ="World" (再送)    |
    |----------------------------------->|
    |           Ack=111                  |
    |<-----------------------------------|
```

このように、シーケンス番号と確認応答番号は、TCPの信頼性を支える核心的な仕組みです。

---

## Iteration 24-26: フラグの判定

次に、TCPの接続制御に使われるフラグを判定する機能を実装します。
フラグは、接続の確立、データの送信、接続の終了など、TCPの様々な状態を制御する
重要な役割を果たします。

### TCPフラグのビット位置

```text
13バイト目のビット配置:
7 6 5 4 3 2 1 0
- - U A P R S F
      R C S S Y I
      G K H T N N
```

### テスト

```rust
#[test]
fn synフラグを判定できる() {
    let mut data = [0u8; 20];
    data[13] = 0x02; // SYNフラグ

    let packet = TcpPacket::new(&data).unwrap();
    assert!(packet.is_syn());
    assert!(!packet.is_ack());
}

#[test]
fn ackフラグを判定できる() {
    let mut data = [0u8; 20];
    data[13] = 0x10; // ACKフラグ

    let packet = TcpPacket::new(&data).unwrap();
    assert!(packet.is_ack());
    assert!(!packet.is_syn());
}

#[test]
fn syn_ackフラグを判定できる() {
    let mut data = [0u8; 20];
    data[13] = 0x12; // SYN + ACKフラグ

    let packet = TcpPacket::new(&data).unwrap();
    assert!(packet.is_syn());
    assert!(packet.is_ack());
}

#[test]
fn finフラグを判定できる() {
    let mut data = [0u8; 20];
    data[13] = 0x01; // FINフラグ

    let packet = TcpPacket::new(&data).unwrap();
    assert!(packet.is_fin());
}
```

### 実装

```rust
impl<'a> TcpPacket<'a> {
    pub fn is_syn(&self) -> bool {
        (self.data[13] & 0x02) != 0
    }

    pub fn is_ack(&self) -> bool {
        (self.data[13] & 0x10) != 0
    }

    pub fn is_fin(&self) -> bool {
        (self.data[13] & 0x01) != 0
    }

    pub fn is_rst(&self) -> bool {
        (self.data[13] & 0x04) != 0
    }
}
```

### なぜこのコードを書くのか？

#### 1. TCPフラグの役割

TCPフラグは、1バイト（8ビット）の中に複数のフラグ情報を詰め込んだものです。
各ビットが独立したフラグを表し、0または1の値を持ちます。

主要なフラグの意味。

- SYN（Synchronize）: 接続確立の開始を要求する
- ACK（Acknowledgment）: 確認応答を示す
- FIN（Finish）: 接続終了を要求する
- RST（Reset）: 接続を強制的にリセットする
- PSH（Push）: データを即座にアプリケーションに渡すよう要求する
- URG（Urgent）: 緊急データが含まれていることを示す

これらのフラグを組み合わせることで、TCPの様々な状態を表現します。

#### 2. なぜ13バイト目なのか

TCPヘッダーの仕様により、フラグは13バイト目に格納されています。

```text
0-3バイト:   ポート番号（送信元2バイト + 宛先2バイト）
4-7バイト:   シーケンス番号
8-11バイト:  確認応答番号
12バイト:    データオフセット + 予約ビット
13バイト:    フラグ（6ビット使用）     ← ここ
14-15バイト: ウィンドウサイズ
...
```

13バイト目の8ビットのうち、下位6ビットがフラグとして使われています。
上位2ビットは予約ビット（将来の拡張用）です。

#### 3. ビット演算とビットマスク

フラグの判定には、ビット演算を使います。
これは、1バイトの中の特定のビットだけを調べるための技法です。

まず、各フラグのビット位置を確認しましょう。

```text
ビット位置: 7  6  5  4  3  2  1  0
フラグ名:   -  - URG ACK PSH RST SYN FIN
16進数:         0x20 0x10 0x08 0x04 0x02 0x01
```

例えば、SYNフラグ（ビット1）を判定するには。

```rust
// ステップ1: ビットマスク0x02を使ってビットANDを取る
self.data[13] & 0x02

// 0x02 = 0b00000010（2進数）
//        ビット1だけが1、他は0
```

具体例で見てみましょう。

```text
【例1: SYNフラグがセットされている場合】
data[13] = 0x02 = 0b00000010

  0b00000010  (data[13])
& 0b00000010  (0x02 マスク)
--------------
  0b00000010  = 0x02 ≠ 0 → true (SYNフラグあり)

【例2: SYNフラグがセットされていない場合】
data[13] = 0x10 = 0b00010000  (ACKだけセット)

  0b00010000  (data[13])
& 0b00000010  (0x02 マスク)
--------------
  0b00000000  = 0x00 = 0 → false (SYNフラグなし)
```

#### 4. 複数フラグの組み合わせ

実際のTCP通信では、複数のフラグが同時にセットされることがよくあります。
例えば、3-wayハンドシェイクの2番目のパケットでは、SYNとACKの両方がセットされます。

```text
SYN + ACKフラグの場合:
data[13] = 0x12 = 0b00010010
                     ↑    ↑
                    ACK  SYN

// SYNのチェック:
  0b00010010  (data[13])
& 0b00000010  (0x02 マスク)
--------------
  0b00000010  ≠ 0 → true (SYNあり)

// ACKのチェック:
  0b00010010  (data[13])
& 0b00010000  (0x10 マスク)
--------------
  0b00010000  ≠ 0 → true (ACKあり)
```

各フラグは独立してチェックできるため、ビットマスクを使った判定が有効です。

#### 5. 実際のTCP通信での使用例

これらのフラグは、TCPの3-wayハンドシェイクで使われます。

```text
【3-wayハンドシェイク】
クライアント                          サーバー
    |                                    |
    | (1) SYNフラグセット                |
    |    (接続したい)                    |
    |----------------------------------->|
    |                                    |
    | (2) SYN + ACKフラグセット          |
    |    (接続OK、確認した)              |
    |<-----------------------------------|
    |                                    |
    | (3) ACKフラグセット                |
    |    (確認した)                      |
    |----------------------------------->|
    |                                    |
    |        接続確立完了                 |
```

コードで表すと。

```rust
// パケット1: SYN
data[13] = 0x02;  // 0b00000010

// パケット2: SYN + ACK
data[13] = 0x12;  // 0b00010010

// パケット3: ACK
data[13] = 0x10;  // 0b00010000
```

#### 6. なぜ != 0 で比較するのか

`(self.data[13] & 0x02) != 0`という条件式を使っている理由は。

- ビットANDの結果が0以外 → そのフラグがセットされている
- ビットANDの結果が0 → そのフラグがセットされていない

これは、ビット演算の結果を真偽値に変換する一般的なパターンです。

別の書き方もできますが、`!= 0`の方が意図が明確です。

```rust
// これらは同じ意味:
(self.data[13] & 0x02) != 0  // 推奨（意図が明確）
(self.data[13] & 0x02) > 0   // 動作は同じだが、やや不自然
```

このように、ビット演算を使うことで、1バイトの中に複数の情報を効率的に
格納・取得できます。これは、ネットワークプロトコルでよく使われる技法です。

---

## Iteration 27: ウィンドウサイズ

次に、TCPのフロー制御に使われるウィンドウサイズを実装します。
ウィンドウサイズは、受信側が「これだけのデータを受け取れます」と
送信側に伝えるための重要な情報です。

### テスト

```rust
#[test]
fn ウィンドウサイズを取得できる() {
    let mut data = [0u8; 20];
    data[14] = 0xff;
    data[15] = 0xff; // 65535

    let packet = TcpPacket::new(&data).unwrap();
    assert_eq!(packet.window_size(), 65535);
}
```

### 実装

```rust
impl<'a> TcpPacket<'a> {
    pub fn window_size(&self) -> u16 {
        u16::from_be_bytes([self.data[14], self.data[15]])
    }
}
```

### なぜこのコードを書くのか？

#### 1. ウィンドウサイズとは何か

ウィンドウサイズは、受信側が「今、あとどれだけのデータを受け取れるか」を
送信側に伝えるための値です。単位はバイトです。

例えば、ウィンドウサイズが8192バイトの場合。

```text
受信側: 「今、8192バイトまで受け取れます」
送信側: 「わかりました。8192バイト以下のデータを送ります」
```

受信側がデータを処理すると、バッファに空きができるため、
ウィンドウサイズは動的に変化します。

#### 2. フロー制御の仕組み

TCPは、送信側が受信側を圧倒しないように「フロー制御」を行います。
ウィンドウサイズは、この制御の核心です。

```text
【フロー制御の例】
受信側                              送信側
バッファ: [      空き 8192バイト      ]
    |                                  |
    | ウィンドウサイズ = 8192          |
    |<----------------------------------|
    |                                  |
    |         4096バイトのデータ        |
    |<----------------------------------|
    |                                  |
バッファ: [使用中4096][空き4096]
    |                                  |
    | ウィンドウサイズ = 4096          |
    |<----------------------------------|
    |                                  |

（アプリケーションが4096バイト読み取る）
バッファ: [      空き 8192バイト      ]
    |                                  |
    | ウィンドウサイズ = 8192          |
    |<----------------------------------|
```

このように、受信側のバッファの状態に応じて、ウィンドウサイズが変化し、
送信側はその値を見て送信量を調整します。

#### 3. なぜ16ビット（2バイト）なのか

ウィンドウサイズは16ビット（2バイト）の値で、0〜65535バイトの範囲を表現できます。

TCPヘッダーの仕様により、ウィンドウサイズは14-15バイト目に格納されています。

```text
0-3バイト:   ポート番号
4-7バイト:   シーケンス番号
8-11バイト:  確認応答番号
12バイト:    データオフセット
13バイト:    フラグ
14-15バイト: ウィンドウサイズ    ← ここ
16-17バイト: チェックサム
...
```

最大値65535バイト（約64KB）は、現代の高速ネットワークでは小さすぎるため、
実際には「ウィンドウスケーリング」というオプションで拡張されることがあります。

#### 4. 実装の詳細

実装は、ポート番号の取得と同じパターンです。

```rust
u16::from_be_bytes([self.data[14], self.data[15]])
```

これは、14-15バイト目の2バイトをビッグエンディアン形式で読み取り、
`u16`型に変換しています。

例。

```text
ウィンドウサイズ = 65535（最大値）の場合:
65535（10進数）= 0xFFFF（16進数）

data[14] = 0xFF  // 上位バイト
data[15] = 0xFF  // 下位バイト

u16::from_be_bytes([0xFF, 0xFF])
→ (0xFF << 8) | 0xFF
→ 0xFF00 | 0x00FF
→ 0xFFFF
→ 65535（10進数）
```

#### 5. ウィンドウサイズ0の特別な意味

ウィンドウサイズが0の場合、受信側は「今、データを受け取れません」という
意味になります。

```text
受信側: ウィンドウサイズ = 0
送信側: データ送信を一時停止

（受信側がバッファを空ける）
受信側: ウィンドウサイズ = 8192
送信側: データ送信を再開
```

これにより、受信側が処理しきれない速度でデータが送られることを防ぎます。

---

## Iteration 28: ペイロードの取得

次に、TCPセグメントの実際のデータ部分（ペイロード）を取得する機能を実装します。
ペイロードは、アプリケーション層のデータ（HTTPリクエスト、ファイルの内容など）が
格納されている部分です。

### テスト

```rust
#[test]
fn ペイロードを取得できる() {
    let mut data = vec![0u8; 30];
    data[12] = 0x50; // Data Offset = 5 (20バイト)
    data[20..30].copy_from_slice(b"HelloWorld");

    let packet = TcpPacket::new(&data).unwrap();
    assert_eq!(packet.payload(), b"HelloWorld");
}
```

### 実装

```rust
impl<'a> TcpPacket<'a> {
    pub fn header_length(&self) -> usize {
        let data_offset = (self.data[12] >> 4) as usize;
        data_offset * 4
    }

    pub fn payload(&self) -> &[u8] {
        let header_len = self.header_length();
        &self.data[header_len..]
    }
}
```

### なぜこのコードを書くのか？

#### 1. ペイロードとは何か

TCPセグメントは、ヘッダー部分とペイロード（データ）部分から構成されています。

```text
+------------------+------------------+
|  TCPヘッダー      |  ペイロード      |
|  (20バイト以上)   |  (可変長)        |
+------------------+------------------+
 ↑                  ↑
 制御情報            実際のデータ
```

ペイロードには、アプリケーション層のデータが格納されます。例えば。

- HTTPリクエスト：`GET /index.html HTTP/1.1\r\nHost: example.com\r\n...`
- ファイル転送：ファイルの内容
- メールデータ：メールの本文

#### 2. Data Offsetとは何か

TCPヘッダーは可変長です。最小20バイトですが、オプションフィールドを含めると
最大60バイトまで拡張できます。

ペイロードがどこから始まるかを知るために、「Data Offset」フィールドが用意されています。
これは12バイト目の上位4ビットに格納されています。

```text
12バイト目のビット配置:
7 6 5 4  3 2 1 0
[Data Offset] [予約]
 ↑
 ヘッダー長を示す（32ビットワード単位）
```

Data Offsetは、「TCPヘッダーの長さを32ビット（4バイト）単位で示す」値です。

例。

- Data Offset = 5 → ヘッダー長 = 5 × 4 = 20バイト（最小ヘッダー）
- Data Offset = 6 → ヘッダー長 = 6 × 4 = 24バイト（4バイトのオプション付き）
- Data Offset = 15 → ヘッダー長 = 15 × 4 = 60バイト（最大ヘッダー）

#### 3. Data Offsetの取得方法

Data Offsetは、12バイト目の上位4ビットに格納されています。
これを取得するには、右シフト演算を使います。

```rust
let data_offset = (self.data[12] >> 4) as usize;
```

具体例。

```text
data[12] = 0x50 = 0b01010000

右シフト4ビット（>> 4）:
  0b01010000
  → 0b00000101
  → 5（10進数）

ヘッダー長 = 5 × 4 = 20バイト
```

別の例。

```text
data[12] = 0x60 = 0b01100000

右シフト4ビット（>> 4）:
  0b01100000
  → 0b00000110
  → 6（10進数）

ヘッダー長 = 6 × 4 = 24バイト
```

右シフト演算（`>>`）は、ビットを右に移動させる操作です。
`>> 4`は「4ビット右にシフト」という意味で、上位4ビットを取り出す効果があります。

#### 4. ペイロードの取得

ヘッダー長が分かれば、ペイロードはその後ろから始まります。

```rust
pub fn payload(&self) -> &[u8] {
    let header_len = self.header_length();
    &self.data[header_len..]
}
```

`&self.data[header_len..]`は、「header_len番目から最後まで」を意味します。

例。

```text
TCPセグメント全体（30バイト）:
[ヘッダー 20バイト][ペイロード 10バイト]
 0          ...19 20        ...29

header_len = 20
&self.data[20..]
→ 20バイト目から最後まで = ペイロード部分
```

#### 5. なぜ参照を返すのか

`payload()`メソッドは、ペイロードのコピーではなく参照（`&[u8]`）を返しています。
これには以下の利点があります。

- 効率性: 大きなペイロード（数KBや数MB）をコピーしない
- ゼロコピー: 元のデータをそのまま参照するため、メモリの無駄がない

これは、パーサー全体で一貫した設計です。`TcpPacket`が元のバイト列への参照を
保持しているのと同じ理由です。

#### 6. 実際の使用例

ペイロードを取得した後、そのデータを上位層のパーサーに渡すことができます。

```rust
let tcp_packet = TcpPacket::new(&data).unwrap();
let payload = tcp_packet.payload();

// ペイロードがHTTPリクエストの場合
if payload.starts_with(b"GET ") || payload.starts_with(b"POST ") {
    // HTTPパーサーにペイロードを渡す
    parse_http_request(payload);
}

// ペイロードがTLSハンドシェイクの場合
if payload.starts_with(b"\x16\x03") {
    // TLSパーサーにペイロードを渡す
    parse_tls_handshake(payload);
}
```

このように、TCPパーサーはペイロードを取り出すだけで、
その解釈は上位層のパーサーに任せます。これが「レイヤー化」の利点です。

---

## Iteration 29: チェックサムの計算（疑似ヘッダー）

最後に、TCPの重要なエラー検出機能であるチェックサムを実装します。
TCPのチェックサムは、IPv4のチェックサムとは異なり、
「疑似ヘッダー」という特別な仕組みを使います。

### 疑似ヘッダーを使ったチェックサム

TCPのチェックサムは、疑似ヘッダー + TCPヘッダー + データを含めて計算します。

### テスト

```rust
use std::net::Ipv4Addr;

#[test]
fn チェックサムを計算できる() {
    let tcp_data = vec![
        0x00, 0x50, // Source Port: 80
        0x1f, 0x90, // Destination Port: 8080
        0x00, 0x00, 0x00, 0x64, // Sequence: 100
        0x00, 0x00, 0x00, 0x00, // Acknowledgment: 0
        0x50, 0x02, // Data Offset: 5, Flags: SYN
        0xff, 0xff, // Window: 65535
        0x00, 0x00, // Checksum: 0 (計算前)
        0x00, 0x00, // Urgent Pointer: 0
    ];

    let src_ip = Ipv4Addr::new(192, 168, 1, 1);
    let dst_ip = Ipv4Addr::new(192, 168, 1, 2);

    let checksum = calculate_tcp_checksum(&tcp_data, src_ip, dst_ip);
    assert_ne!(checksum, 0);
}
```

### 実装

```rust
use std::net::Ipv4Addr;

pub fn calculate_tcp_checksum(tcp_segment: &[u8], src_ip: Ipv4Addr, dst_ip: Ipv4Addr) -> u16 {
    let mut sum: u32 = 0;

    // 疑似ヘッダーの追加
    for &byte in src_ip.octets().iter() {
        sum += byte as u32;
    }
    for &byte in dst_ip.octets().iter() {
        sum += byte as u32;
    }
    sum += 6; // Protocol: TCP
    sum += tcp_segment.len() as u32;

    // TCPセグメント全体を16ビットワードで加算
    for i in (0..tcp_segment.len()).step_by(2) {
        let word = if i + 1 < tcp_segment.len() {
            u16::from_be_bytes([tcp_segment[i], tcp_segment[i + 1]]) as u32
        } else {
            (tcp_segment[i] as u32) << 8
        };
        sum += word;
    }

    // キャリーを折り返す
    while (sum >> 16) != 0 {
        sum = (sum & 0xffff) + (sum >> 16);
    }

    // 1の補数を取る
    !(sum as u16)
}
```

### なぜこのコードを書くのか？

#### 1. チェックサムとは何か

チェックサムは、データが転送中に壊れていないかを検証するための値です。
送信側と受信側で同じ計算を行い、結果が一致するかを確認します。

```text
送信側:
1. チェックサム欄を0にしてパケットを作る
2. チェックサムを計算する
3. 計算結果をチェックサム欄に書き込む
4. パケットを送信

受信側:
1. パケットを受信
2. チェックサム欄を含めて計算する
3. 結果が0になれば正常、そうでなければエラー
```

#### 2. 疑似ヘッダーとは何か

TCPのチェックサムには、「疑似ヘッダー」という特別な仕組みがあります。
疑似ヘッダーは、実際のパケットには含まれないが、チェックサム計算には含める
仮想的なヘッダーです。

疑似ヘッダーの構造。

```text
+--------+--------+--------+--------+
|     Source IP Address (4バイト)   |  ← IPv4ヘッダーから
+--------+--------+--------+--------+
|   Destination IP Address (4バイト)|  ← IPv4ヘッダーから
+--------+--------+--------+--------+
|  Zero  |  PTCL  | TCP Length (2バイト)|
| (1バイト)|(1バイト)|                    |
+--------+--------+--------+--------+

Zero = 0x00（予約）
PTCL = 6（TCPのプロトコル番号）
TCP Length = TCPセグメントの全長
```

なぜ疑似ヘッダーが必要なのか？

疑似ヘッダーには、以下の目的があります。

- 誤配送の検出: パケットが正しい宛先IPアドレスに届いたかを検証
- プロトコルの検証: TCPパケットとして正しく処理されているかを検証
- 長さの検証: TCPセグメントの長さが正しいかを検証

例えば、ルーターのバグでIPヘッダーの宛先アドレスが書き換えられても、
TCPチェックサムが一致しないためエラーを検出できます。

#### 3. チェックサム計算の手順

TCPチェックサムは、以下の手順で計算します。

#### ステップ1: 疑似ヘッダーの加算

```rust
// 送信元IPアドレス（例: 192.168.1.1）
sum += 192 + 168 + 1 + 1  // バイト単位で加算

// 宛先IPアドレス（例: 192.168.1.2）
sum += 192 + 168 + 1 + 2

// プロトコル番号（TCP = 6）
sum += 6

// TCPセグメントの長さ（例: 20バイト）
sum += 20
```

#### ステップ2: TCPセグメント全体を16ビットワード単位で加算

```rust
for i in (0..tcp_segment.len()).step_by(2) {
    let word = if i + 1 < tcp_segment.len() {
        // 2バイトある場合
        u16::from_be_bytes([tcp_segment[i], tcp_segment[i + 1]]) as u32
    } else {
        // 最後の1バイトだけの場合（奇数長）
        (tcp_segment[i] as u32) << 8
    };
    sum += word;
}
```

例。

```text
TCPセグメント（最初の8バイト）:
0x00 0x50  0x1f 0x90  0x00 0x00  0x00 0x64

16ビットワードに分割:
0x0050 + 0x1f90 + 0x0000 + 0x0064

sum += 0x0050  // 80（ポート番号）
sum += 0x1f90  // 8080（ポート番号）
sum += 0x0000  // シーケンス番号の上位2バイト
sum += 0x0064  // シーケンス番号の下位2バイト（100）
...
```

#### ステップ3: キャリーの折り返し

16ビットを超えた部分（キャリー）を、下位16ビットに加算します。

```rust
while (sum >> 16) != 0 {
    sum = (sum & 0xffff) + (sum >> 16);
}
```

例。

```text
sum = 0x0001FFFF（32ビット）

キャリー（上位16ビット）: 0x0001
下位16ビット: 0xFFFF

折り返し後:
sum = 0xFFFF + 0x0001 = 0x10000

再度折り返し:
sum = 0x0000 + 0x0001 = 0x0001
```

#### ステップ4: 1の補数を取る

最後に、ビット反転（1の補数）を行います。

```rust
!(sum as u16)
```

例。

```text
sum = 0x0001 = 0b0000000000000001

1の補数:
!0b0000000000000001 = 0b1111111111111110 = 0xFFFE
```

#### 4. なぜIPアドレスが必要なのか

TCPチェックサムの計算には、IPアドレスが必要です。
これは、疑似ヘッダーにIPv4ヘッダーの情報（送信元・宛先IPアドレス）が
含まれるためです。

```rust
pub fn calculate_tcp_checksum(
    tcp_segment: &[u8],
    src_ip: Ipv4Addr,   // ← IPv4ヘッダーから取得
    dst_ip: Ipv4Addr    // ← IPv4ヘッダーから取得
) -> u16
```

つまり、TCPパーサー単体ではチェックサムを検証できません。
IPv4パケットと組み合わせて初めて、正しいチェックサム検証ができます。

#### 5. 奇数長のデータへの対応

TCPセグメントの長さが奇数の場合、最後の1バイトをどう扱うかが問題になります。

実装では、最後の1バイトを上位バイトとして扱います。

```rust
if i + 1 < tcp_segment.len() {
    // 2バイトある場合: そのまま16ビットワードに
    u16::from_be_bytes([tcp_segment[i], tcp_segment[i + 1]]) as u32
} else {
    // 1バイトだけの場合: 上位バイトとして扱い、下位は0
    (tcp_segment[i] as u32) << 8
}
```

例。

```text
最後の1バイトが 0xAB の場合:
(0xAB << 8) = 0xAB00
```

#### 6. チェックサム検証の実装

受信側でチェックサムを検証する場合、チェックサムフィールドを含めて
計算し、結果が0になることを確認します。

```rust
impl<'a> TcpPacket<'a> {
    pub fn verify_checksum(&self, src_ip: Ipv4Addr, dst_ip: Ipv4Addr) -> bool {
        let checksum = calculate_tcp_checksum(self.data, src_ip, dst_ip);
        checksum == 0  // チェックサム含めて計算すると0になる
    }
}
```

これは、送信側がチェックサムの1の補数を格納しているため、
受信側で再計算すると相殺されて0になるという性質を利用しています。

このように、TCPのチェックサムは、IPv4のチェックサムよりも複雑ですが、
より強力なエラー検出を実現しています。

---

## Phase 4のまとめ

このフェーズでは、以下を学びました。

### TCPの理解

TCPプロトコルの核心的な機能を学びました。ポート番号によるアプリケーションの識別方法を理解し、SYN、ACK、FINなどのフラグによる接続制御の仕組みを習得しました。また、3-wayハンドシェイクによる接続確立のプロセスと、疑似ヘッダーを使ったチェックサム計算の実装方法を学びました。

### Rustの機能

Rustを使った実装技術を習得しました。ビット演算を使ったフラグの判定方法を学び、シーケンス番号などの32ビット整数の扱い方を理解しました。また、複雑なチェックサム計算を正確に実装する方法も習得しました。

### TDDの実践

TDDでの効果的な開発手法を実践しました。機能を段階的に追加することで、複雑な実装を確実に進められることを体験しました。また、各フラグごとに個別のテストを作成することで、複雑なロジック（チェックサム計算など）も小さく分割して実装できることを学びました。

---

## 次のステップ

Phase 4が完了しました！次は[Phase 5: パケットビルダー](./phase5-packet-builder.md)に進みましょう。

これまでパーサー（データの読み取り）を実装してきましたが、次はビルダー（データの構築）を実装します。パケットを自分で作れるようになることで、スタックの理解がさらに深まります。

---

## ナビゲーション

- 前へ：[Phase 3: IPv4パケットパーサー](./phase3-ipv4-packet.md)
- 次へ：[Phase 5: パケットビルダー](./phase5-packet-builder.md)
- ホーム：[README](../README.md)
