# RustでTCP/IPスタックをt-wada流TDDで実装する

## 概要

このハンズオンでは、Rustを使ってTCP/IPプロトコルスタックを実装しながら、TDD（テスト駆動開発）のプロセスを体験します。

完成したコードを見るのではなく、Red → Green → Refactor のサイクルを一歩ずつ進めていくことで、テスト駆動開発の本質を理解します。

### このハンズオンで学べること

- TDDの実践的な進め方：Red → Green → Refactorのサイクルを体で覚える
- TCP/IPプロトコルスタックの仕組み：Ethernet、IPv4、TCPの各レイヤーの実装を通じてネットワークの基礎を理解
- Rustでの低レベルプログラミング：バイト列操作、ビット演算、型安全性を活かした実装

### ハンズオンの構成

1. [Phase 1: MACアドレス実装](./phase1-mac-address.md)
2. [Phase 2: Ethernetフレームパーサー](./phase2-ethernet-frame.md)
3. [Phase 3: IPv4パケットパーサー](./phase3-ipv4-packet.md)
4. [Phase 4: TCPパケットパーサー](./phase4-tcp-packet.md)
5. [Phase 5: パケットビルダー](./phase5-packet-builder.md)
6. [統合テスト](./integration-testing.md)
7. [まとめと次のステップ](./summary.md)

---

## TDDの心構え

テスト駆動開発（Test-Driven Development）は、単なるテスト手法ではありません。ソフトウェア設計の手法であり、開発のリズムです。

```text
「動作するきれいなコード」がゴール。
でも一度には作らない。

1. まず「動作する」を作る（テストを通す）
2. 次に「きれい」にする（リファクタリング）

この順番を守る。
```

### TDDの3つのルール

1. 失敗するテストを書くまでは、プロダクションコードを書かない
2. コンパイルが通らないか、失敗するテストを必要以上に書かない
3. 現在失敗しているテストをパスさせる以上のプロダクションコードを書かない

これらのルールを守ることで、常にテストとコードが同期し、設計がシンプルに保たれます。

---

## TDDのサイクル

TDDは以下のサイクルを繰り返します。このリズムを体で覚えることが重要です。

```text
1. TODOリストを書く（頭の整理）
2. テストを一つだけ選んで書く（Red）
3. テストを実行して、失敗することを確認（Red確認）
4. テストを通す最小限のコードを書く（Green）
5. テストを実行して、成功を確認（Green確認）
6. リファクタリング（Refactor）
7. すべてのテストを実行して、壊れていないことを確認
8. 次のテストへ戻る
```

### Red → Green → Refactor

- Red（赤）：失敗するテストを書く
  - コンパイルエラーも"Red"
  - 必ずテストを実行して、期待通りに失敗することを確認する

- Green（緑）：そのテストだけを通す最小限のコードを書く
  - 「ベタ書き」でも構わない
  - まずは動くことを優先する

- Refactor（リファクタリング）：テストを保ったままコードをきれいにする
  - 重複を排除する
  - 意図を明確にする
  - 全テストが通ることを確認する

このサイクルを小さく、速く回すことがTDDの本質です。

---

## 環境セットアップ

### プロジェクトの作成

Rustプロジェクトは、ライブラリプロジェクトまたはバイナリプロジェクトとして作成できます。

#### ライブラリプロジェクトとして作成する場合

```bash
cargo new rust-tcp-stack --lib
cd rust-tcp-stack
```

- エントリーポイント：`src/lib.rs`
- 主に再利用可能なコードを書く場合に適しています

#### バイナリプロジェクトとして作成する場合

```bash
cargo new rust-tcp-stack
cd rust-tcp-stack
```

- エントリーポイント：`src/main.rs`
- 実行可能なアプリケーションを作る場合に適しています

### Cargo.tomlの設定

```toml
[package]
name = "rust-tcp-stack"
version = "0.1.0"
edition = "2021"

[dependencies]

[dev-dependencies]
```

### モジュールの宣言

新しいモジュール（例：`ethernet.rs`）を追加したら、必ずエントリーポイントに`mod モジュール名;`を追加する必要があります。

#### ライブラリプロジェクトの場合（src/lib.rs）

```rust
pub mod ethernet;
pub mod ipv4;
pub mod tcp;
```

#### バイナリプロジェクトの場合（src/main.rs）

```rust
mod ethernet;
mod ipv4;
mod tcp;

fn main() {
    println!("Hello, world!");
}
```

---

## 重要な用語の基礎知識

このハンズオンでは、TCP/IPプロトコルスタックに関する複数の概念が登場します。各フェーズで詳しく解説しますが、ここでは全体像を把握するための基礎知識を紹介します。

### TCP/IPの階層モデル

TCP/IPプロトコルスタックは、以下の4つの層から構成されています。

```text
+----------------------------+
|   アプリケーション層        |  (HTTP, FTP, etc.)
+----------------------------+
|   トランスポート層          |  (TCP, UDP)
+----------------------------+
|   インターネット層          |  (IP, ICMP)
+----------------------------+
|   ネットワークインターフェース層 |  (Ethernet, Wi-Fi)
+----------------------------+
```

このハンズオンでは、以下の層を実装します。

1. ネットワークインターフェース層：Ethernet（Phase 1, 2）
2. インターネット層：IPv4（Phase 3）
3. トランスポート層：TCP（Phase 4）

### データの流れ

データは各層で「カプセル化」されます。各層がヘッダー情報を追加していくイメージです。

```text
アプリケーションデータ
↓
[TCPヘッダー | データ]                  ← トランスポート層
↓
[IPヘッダー | TCPヘッダー | データ]      ← インターネット層
↓
[Ethernetヘッダー | IPヘッダー | TCPヘッダー | データ] ← ネットワークインターフェース層
```

受信時は逆に、各層が自分のヘッダーを「デカプセル化」してペイロード（中身）を次の層に渡します。

### パケット、フレーム、セグメント

- フレーム（Frame）：ネットワークインターフェース層のデータ単位（例：Ethernetフレーム）
- パケット（Packet）：インターネット層のデータ単位（例：IPパケット）
- セグメント（Segment）：トランスポート層のデータ単位（例：TCPセグメント）

---

## 次のステップ

環境セットアップが完了したら、[Phase 1: MACアドレス実装](./phase1-mac-address.md)に進みましょう。

最初のフェーズでは、Ethernetの基礎となるMACアドレスをTDDで実装します。小さく始めて、Red → Green → Refactorのリズムを体で覚えていきましょう。

---

## ナビゲーション

- 次へ：[Phase 1: MACアドレス実装](./phase1-mac-address.md)
- ホーム：[README](../README.md)
