# Phase 3: IPv4パケットパーサー（TDDで）

## このフェーズで学ぶこと

このフェーズでは、IPv4プロトコルの構造と役割について学びます。具体的には、IPアドレスの扱い方を習得し、ヘッダー長の可変性への対応方法を理解します。また、チェックサムの計算と検証の実装を通じて、TDDでの複雑なロジックの構築方法を学びます。

---

## IPv4とは？

IPv4（Internet Protocol version 4）は、インターネット層で使用されるプロトコルで、異なるネットワーク間でデータを転送するための仕組みを提供します。

### IPv4の役割

1. アドレッシング: IPアドレスによるデバイスの識別
2. ルーティング: パケットを宛先まで届けるための経路選択
3. フラグメンテーション: パケットの分割と再構成
4. エラー検出: チェックサムによるヘッダーの整合性確認

### IPアドレスとは？

IPアドレスは、ネットワーク上のデバイスを識別するための論理的なアドレスです。

- 長さ: 32ビット（4バイト）
- 表記: ドット区切りの10進数（例：`192.168.1.1`）
- 構成: ネットワーク部 + ホスト部

MACアドレスとの違い。

- MACアドレス: 物理アドレス、同じネットワーク内の識別
- IPアドレス: 論理アドレス、異なるネットワーク間の識別

---

## IPv4パケットの構造

```text
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (可変長)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 主要フィールド

1. Version（4ビット）: プロトコルバージョン（IPv4の場合は`4`）
2. IHL（Internet Header Length, 4ビット）: ヘッダー長（32ビットワード単位、最小値5 = 20バイト）
3. Total Length（16ビット）: パケット全体の長さ（ヘッダー + データ）
4. Protocol（8ビット）: 上位層のプロトコル（例：TCP=6, UDP=17, ICMP=1）
5. Header Checksum（16ビット）: ヘッダーの整合性確認
6. Source Address（32ビット）: 送信元IPアドレス
7. Destination Address（32ビット）: 宛先IPアドレス

### チェックサムとは？

チェックサム（Checksum）は、データの整合性を確認するための値です。送信時に計算し、受信時に再計算して一致するかを確認します。

IPv4のチェックサム計算。

1. ヘッダーを16ビットワードに分割
2. すべてを加算（桁あふれは折り返し）
3. 1の補数を取る

---

## プロトコル番号

IPv4の`Protocol`フィールドは、ペイロードに含まれる上位層のプロトコルを識別します。

| 値 | プロトコル | 説明 |
|----|----------|------|
| 1 | ICMP | Internet Control Message Protocol（ping等） |
| 6 | TCP | Transmission Control Protocol |
| 17 | UDP | User Datagram Protocol |

---

## TODOリスト（Phase 3）

```text
IPv4パケットパーサー
□ 20バイト未満のデータは拒否する
□ バージョン4以外は拒否する
□ 20バイト以上のバージョン4データは受け入れる
□ 送信元IPアドレスを取得できる
□ 宛先IPアドレスを取得できる
□ プロトコルを取得できる
□ ヘッダー長を取得できる
□ ペイロードを取得できる
□ チェックサムを計算できる
□ チェックサムを検証できる
```

---

## モジュールのセットアップ

`src/ipv4.rs`を作成します。

```rust
use std::net::Ipv4Addr;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ipv4パケットは20バイト未満を拒否する() {
        let short_data = [0u8; 19];
        assert!(Ipv4Packet::new(&short_data).is_none());
    }
}
```

重要: モジュール宣言を忘れずに！

### ライブラリプロジェクトの場合（src/lib.rs）

```rust
pub mod ethernet;
pub mod ipv4;
```

### バイナリプロジェクトの場合（src/main.rs）

```rust
mod ethernet;
mod ipv4;

fn main() {
    println!("Hello, world!");
}
```

---

## Iteration 10: 20バイト未満のデータは拒否する

### Step 1-4: Red → Green

```rust
pub struct Ipv4Packet<'a> {
    data: &'a [u8],
}

impl<'a> Ipv4Packet<'a> {
    pub fn new(data: &'a [u8]) -> Option<Self> {
        if data.len() < 20 {
            return None;
        }
        Some(Ipv4Packet { data })
    }
}
```

---

## Iteration 11: バージョン4以外は拒否する

IPv4パケットは、最初の4ビットが`4`である必要があります。

### Step 1: テストを書く（Red）

```rust
#[test]
fn バージョンが4でない場合は拒否する() {
    let mut data = [0u8; 20];
    data[0] = 0x60; // バージョン6（IPv6）
    assert!(Ipv4Packet::new(&data).is_none());
}
```

### Step 2-4: Red → Green

```rust
impl<'a> Ipv4Packet<'a> {
    pub fn new(data: &'a [u8]) -> Option<Self> {
        if data.len() < 20 {
            return None;
        }

        let version = data[0] >> 4;
        if version != 4 {
            return None;
        }

        Some(Ipv4Packet { data })
    }
}
```

この実装では、ビット演算を使ってバージョンフィールドを取得しています。`data[0] >> 4`という記法で上位4ビットを取得できます。ここでの`>>`は右シフト演算子です。

#### なぜこのコードを書くのか？

#### 1. バージョンフィールドの役割

IPv4パケットの最初の4ビット（バイト0の上位4ビット）には、IPプロトコルのバージョン番号が格納されています。これは、受信したパケットがどのバージョンのIPプロトコルを使用しているかを識別するための重要なフィールドです。

主なIPプロトコルのバージョン。

- バージョン4（IPv4）: 現在最も広く使われているIPプロトコル
- バージョン6（IPv6）: 次世代のIPプロトコル、アドレス空間が大幅に拡大

このパーサーはIPv4専用なので、バージョンが`4`でない場合は処理できません。そのため、バージョンチェックを行い、IPv4以外のパケットは拒否します。

#### 2. 右シフト演算の仕組み

`data[0] >> 4`という記法は、「右シフト演算」と呼ばれるビット操作です。これは、バイトの中から特定のビットを取り出すための基本的な技法です。

具体例で見てみましょう。

```text
data[0] = 0x45 の場合:

2進数表記: 0100 0101
           ^^^^ ^^^^
           上位  下位
           4bit  4bit

右シフト4ビット (>> 4):
0100 0101 >> 4
    ↓
0000 0100  = 0x04 = 4

結果: バージョン = 4 (IPv4)
```

別の例（IPv6の場合）:

```text
data[0] = 0x60 の場合:

2進数表記: 0110 0000
           ^^^^ ^^^^
           上位  下位

右シフト4ビット (>> 4):
0110 0000 >> 4
    ↓
0000 0110  = 0x06 = 6

結果: バージョン = 6 (IPv6) → 拒否
```

#### 3. 上位4ビットと下位4ビット

IPv4ヘッダーの最初の1バイトには、2つの情報が詰め込まれています。

```text
バイト0の構造:
+--------+--------+
| Version|  IHL   |
| (4bit) | (4bit) |
+--------+--------+
  0x4      0x5

合わせて 0x45
```

- 上位4ビット: バージョン（Version）
- 下位4ビット: ヘッダー長（IHL = Internet Header Length）

右シフト演算（`>> 4`）を使うことで、上位4ビットだけを取り出すことができます。

#### 4. なぜOption型を返すのか

バージョンチェックが失敗した場合、`None`を返すことでエラーを安全に扱えます。これにより、呼び出し側は以下のように処理できます。

```rust
// パースに失敗した場合の安全な処理
if let Some(packet) = Ipv4Packet::new(&data) {
    // IPv4パケットとして処理
    println!("Source: {}", packet.source());
} else {
    // IPv4ではないパケット、または不正なデータ
    eprintln!("Not a valid IPv4 packet");
}
```

この設計により、パース失敗時にパニックを起こすことなく、呼び出し側で適切にエラーハンドリングできます。

---

## Iteration 12: 送信元・宛先IPアドレスを取得できる

### Step 1: テストを書く（Red）

```rust
#[test]
fn 送信元ipアドレスを取得できる() {
    let mut data = [0u8; 20];
    data[0] = 0x45; // バージョン4, IHL=5
    data[12..16].copy_from_slice(&[192, 168, 1, 1]);

    let packet = Ipv4Packet::new(&data).unwrap();
    assert_eq!(packet.source(), Ipv4Addr::new(192, 168, 1, 1));
}

#[test]
fn 宛先ipアドレスを取得できる() {
    let mut data = [0u8; 20];
    data[0] = 0x45; // バージョン4, IHL=5
    data[16..20].copy_from_slice(&[10, 0, 0, 1]);

    let packet = Ipv4Packet::new(&data).unwrap();
    assert_eq!(packet.destination(), Ipv4Addr::new(10, 0, 0, 1));
}
```

### Step 2-4: Red → Green

```rust
use std::net::Ipv4Addr;

impl<'a> Ipv4Packet<'a> {
    // ... 既存のメソッド ...

    pub fn source(&self) -> Ipv4Addr {
        Ipv4Addr::new(
            self.data[12],
            self.data[13],
            self.data[14],
            self.data[15],
        )
    }

    pub fn destination(&self) -> Ipv4Addr {
        Ipv4Addr::new(
            self.data[16],
            self.data[17],
            self.data[18],
            self.data[19],
        )
    }
}
```

この実装には3つのポイントがあります。まず、Rustの標準ライブラリで提供される`Ipv4Addr`型を使用しています。また、送信元アドレスは12〜15バイト目、宛先アドレスは16〜19バイト目に位置するというIPv4ヘッダーの仕様に従っています。

#### なぜこのコードを書くのか？

#### 1. IPアドレスの構造

IPアドレス（Internet Protocol Address）は、ネットワーク上のデバイスを識別するための論理的なアドレスです。IPv4アドレスは32ビット（4バイト）で構成され、通常はドット区切りの10進数で表記されます。

```text
IPアドレスの構造:

32ビット = 4バイト = 4オクテット

+--------+--------+--------+--------+
|  192   |  168   |   1    |   1    |
+--------+--------+--------+--------+
  8bit     8bit     8bit     8bit

ドット区切り表記: 192.168.1.1

バイナリ表記:
11000000.10101000.00000001.00000001
```

各オクテット（8ビット）は0〜255の値を取ることができます。

#### 2. IPv4ヘッダー内のIPアドレスの位置

IPv4ヘッダーの中で、IPアドレスは決められた位置に格納されています。

```text
IPv4ヘッダーのレイアウト（20バイト）:

バイト位置:
 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|Ver|IHL|TOS|Total Length |ID |Flg|Frag|TTL|Pro|Checksum   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|           Source IP Address (12-15)                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|        Destination IP Address (16-19)                     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

送信元IPアドレス: バイト12-15 (4バイト)
宛先IPアドレス:   バイト16-19 (4バイト)
```

この位置は、RFC 791（IPv4の仕様書）で定義されており、すべてのIPv4実装で共通です。

#### 3. Ipv4Addr型の利用

Rustの標準ライブラリには`std::net::Ipv4Addr`という便利な型が用意されています。この型を使うことで、IPアドレスを扱いやすくなります。

```rust
use std::net::Ipv4Addr;

// 4つのオクテットから作成
let ip = Ipv4Addr::new(192, 168, 1, 1);

// ドット区切り表記で表示
println!("{}", ip);  // "192.168.1.1"

// オクテットの配列として取得
let octets = ip.octets();  // [192, 168, 1, 1]
```

#### 4. バイト列からIPアドレスへの変換

実装コードでは、バイト列から直接`Ipv4Addr`を構築しています。

```rust
pub fn source(&self) -> Ipv4Addr {
    Ipv4Addr::new(
        self.data[12],  // 第1オクテット
        self.data[13],  // 第2オクテット
        self.data[14],  // 第3オクテット
        self.data[15],  // 第4オクテット
    )
}
```

具体例。

```text
パケットのバイト列:
data[12] = 192 = 0xC0
data[13] = 168 = 0xA8
data[14] = 1   = 0x01
data[15] = 1   = 0x01

↓

Ipv4Addr::new(192, 168, 1, 1)

↓

表示: "192.168.1.1"
```

#### 5. MACアドレスとIPアドレスの違い

これまで学んだMACアドレスとIPアドレスの違いを整理しておきましょう。

| 特徴 | MACアドレス | IPアドレス |
|------|-----------|-----------|
| 層 | ネットワークインターフェース層 | インターネット層 |
| 長さ | 48ビット（6バイト） | 32ビット（4バイト） |
| 表記 | `aa:bb:cc:dd:ee:ff` | `192.168.1.1` |
| 範囲 | 同じネットワーク内 | 異なるネットワーク間 |
| 性質 | 物理アドレス（ハードウェア固有） | 論理アドレス（設定可能） |

IPアドレスは、ルーターを越えて異なるネットワーク間でパケットを届けるために必要な情報です。

---

## Iteration 13: プロトコルを取得できる

### Step 1: テストを書く（Red）

```rust
#[test]
fn プロトコルがtcpの場合() {
    let mut data = [0u8; 20];
    data[0] = 0x45;
    data[9] = 6; // TCP

    let packet = Ipv4Packet::new(&data).unwrap();
    assert_eq!(packet.protocol(), IpProtocol::Tcp);
}
```

### Step 2-4: Red → Green

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IpProtocol {
    Icmp,
    Tcp,
    Udp,
    Unknown(u8),
}

impl<'a> Ipv4Packet<'a> {
    pub fn protocol(&self) -> IpProtocol {
        match self.data[9] {
            1 => IpProtocol::Icmp,
            6 => IpProtocol::Tcp,
            17 => IpProtocol::Udp,
            n => IpProtocol::Unknown(n),
        }
    }
}
```

#### なぜこのコードを書くのか？

#### 1. プロトコルフィールドの役割

IPv4パケットの9バイト目には、「ペイロードに格納されている上位層のプロトコル」を示すプロトコル番号が入っています。これは、IPv4層がデータを受信した後、どの上位層プロトコル（TCP、UDP、ICMPなど）にデータを渡すべきかを判断するための重要な情報です。

```text
IPv4ヘッダーの構造:

バイト位置: 0  1  2  3  4  5  6  7  8  9  10 ...
           +--+--+--+--+--+--+--+--+--+--+--+
           |...|...|...|...|...|...|...|TTL|Pro| ← 9バイト目がプロトコル
           +--+--+--+--+--+--+--+--+--+--+--+
```

#### 2. プロトコル多重化とは

ネットワーク層では、「多重化（Multiplexing）」という概念が重要です。一つのネットワークインターフェースで、複数の上位層プロトコル（TCP、UDP、ICMPなど）を同時に扱う必要があります。

```text
アプリケーション層
    |
    | 複数のプロトコルが同時に動作
    v
+-------+-------+-------+
|  TCP  |  UDP  | ICMP  |  ← トランスポート層
+-------+-------+-------+
    |       |       |
    +-------+-------+
          |
          v
      [ IPv4 ]  ← プロトコル番号で識別
          |
          v
    [ Ethernet ]

受信時の流れ:
1. Ethernetフレームを受信
2. IPv4パケットをパース
3. プロトコルフィールドを確認（例: 6 = TCP）
4. TCPにペイロードを渡す
```

プロトコルフィールドがないと、IPv4層は受信したデータをどのプロトコルに渡すべきか判断できません。

#### 3. 主要なプロトコル番号

プロトコル番号は、IANA（Internet Assigned Numbers Authority）によって管理されています。主要なプロトコル番号は以下の通りです。

| プロトコル番号 | プロトコル名 | 用途 |
|--------------|------------|------|
| 1 | ICMP | Internet Control Message Protocol（エラー報告、ping） |
| 6 | TCP | Transmission Control Protocol（信頼性のある通信） |
| 17 | UDP | User Datagram Protocol（高速な通信） |
| 41 | IPv6 | IPv6カプセル化（IPv4トンネル） |
| 47 | GRE | Generic Routing Encapsulation（VPN等） |

完全なリストは[IANAのウェブサイト](https://www.iana.org/assignments/protocol-numbers/)で確認できます。

#### 4. Unknown(u8)の設計理由

`IpProtocol` enumには`Unknown(u8)`というバリアントがあります。これは、未知のプロトコル番号を安全に扱うための設計です。

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IpProtocol {
    Icmp,
    Tcp,
    Udp,
    Unknown(u8),  // 未知のプロトコル番号を保持
}
```

この設計により、以下のメリットがあります。

柔軟性: 実装していないプロトコル番号でもパースエラーにならない

```rust
// プロトコル番号 50 (ESP - IPsec) の場合
let protocol = packet.protocol();
match protocol {
    IpProtocol::Tcp => { /* TCP処理 */ }
    IpProtocol::Udp => { /* UDP処理 */ }
    IpProtocol::Unknown(50) => {
        println!("ESP protocol detected");
        // 未実装でも情報は保持される
    }
    _ => { /* その他 */ }
}
```

情報の保存: 元のプロトコル番号の値を保持できる

```rust
// 元の値を取り出せる
if let IpProtocol::Unknown(num) = protocol {
    println!("Unknown protocol number: {}", num);
}
```

拡張性: 将来的に新しいプロトコルを追加しやすい

```rust
// 新しいプロトコルを追加する場合
pub enum IpProtocol {
    Icmp,
    Tcp,
    Udp,
    Esp,  // 新規追加
    Unknown(u8),
}
```

#### 5. バイト位置9の意味

プロトコルフィールドがバイト9に位置するのは、RFC 791（IPv4の仕様）で定義されています。

```text
IPv4ヘッダーの詳細レイアウト:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         | ← バイト0-3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    | ← バイト4-7
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       | ← バイト8-11
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ↑              ↑
   バイト8        バイト9 (Protocol)
```

このレイアウトは世界中のすべてのIPv4実装で共通であり、互換性を保つために厳密に守られています。

---

## Iteration 14: ヘッダー長を取得・ペイロードを取得

### ヘッダー長（IHL）とは？

IPv4ヘッダーは可変長です。IHL（Internet Header Length）フィールドは、ヘッダー長を32ビットワード（4バイト）単位で示します。

- IHL=5 → 5 × 4 = 20バイト（最小）
- IHL=6 → 6 × 4 = 24バイト（オプション4バイト）

### Step 1: テストを書く（Red）

```rust
#[test]
fn ヘッダー長を取得できる() {
    let mut data = [0u8; 20];
    data[0] = 0x45; // バージョン4, IHL=5

    let packet = Ipv4Packet::new(&data).unwrap();
    assert_eq!(packet.header_length(), 20);
}

#[test]
fn ペイロードを取得できる() {
    let mut data = vec![0u8; 30];
    data[0] = 0x45; // IHL=5 → ヘッダー20バイト
    data[20..30].copy_from_slice(b"HelloWorld");

    let packet = Ipv4Packet::new(&data).unwrap();
    assert_eq!(packet.payload(), b"HelloWorld");
}
```

### Step 2-4: Red → Green

```rust
impl<'a> Ipv4Packet<'a> {
    pub fn header_length(&self) -> usize {
        let ihl = self.data[0] & 0x0f; // 下位4ビット
        (ihl as usize) * 4
    }

    pub fn payload(&self) -> &[u8] {
        let header_len = self.header_length();
        &self.data[header_len..]
    }
}
```

ヘッダー長の取得には、ビット演算を使用します。`data[0] & 0x0f`という記法で下位4ビット（IHLフィールド）を取得できます。ここでの`&`はAND演算子です。

#### なぜこのコードを書くのか？

#### 1. IPv4ヘッダーが可変長である理由

IPv4ヘッダーの長さは固定ではなく、20バイト（最小）から60バイト（最大）まで可変です。これは、「オプション」フィールドという拡張機能が存在するためです。

```text
IPv4ヘッダーの構造:

+---------------------+  ← 0バイト目
|  固定部分 (20バイト) |
|  - バージョン        |
|  - IHL              |
|  - プロトコル        |
|  - IPアドレス等      |
+---------------------+  ← 20バイト目
|  オプション (可変)   |  ← 0〜40バイト
|  - タイムスタンプ    |
|  - ルート記録等      |
+---------------------+  ← ヘッダー終端（可変）
|  ペイロード         |
|  (TCPセグメント等)   |
+---------------------+
```

オプションの例。

- タイムスタンプ: パケット送信時刻の記録
- ルート記録: パケットが通過したルーターのIPアドレス記録
- ストリクトルーティング: 指定されたルートを強制

#### 2. IHL（Internet Header Length）の詳細

IHLフィールドは、バイト0の下位4ビットに格納されており、ヘッダー長を「32ビットワード（4バイト）単位」で表します。

```text
バイト0の構造（復習）:
+--------+--------+
| Version|  IHL   |
| (4bit) | (4bit) |
+--------+--------+
  0x4      0x5

IHL = 5 の場合:
5 × 4バイト = 20バイト（最小ヘッダー長、オプションなし）

IHL = 6 の場合:
6 × 4バイト = 24バイト（オプション4バイト）

IHL = 15 の場合（最大値）:
15 × 4バイト = 60バイト（オプション40バイト）
```

#### 3. AND演算による下位4ビットの抽出

`data[0] & 0x0f`というビット演算を使って、下位4ビット（IHL）だけを取り出します。

```text
data[0] = 0x45 の場合:

2進数表記:
data[0]  = 0100 0101
0x0f     = 0000 1111
           ↓ AND演算
結果     = 0000 0101 = 0x05 = 5

IHL = 5
ヘッダー長 = 5 × 4 = 20バイト
```

別の例（オプション付き）:

```text
data[0] = 0x46 の場合:

2進数表記:
data[0]  = 0100 0110
0x0f     = 0000 1111
           ↓ AND演算
結果     = 0000 0110 = 0x06 = 6

IHL = 6
ヘッダー長 = 6 × 4 = 24バイト
（オプション4バイトあり）
```

#### 4. AND演算の仕組み

AND演算（`&`）は、2つのビットが両方とも1の場合のみ1を返すビット演算です。

```text
AND演算の真理値表:
A | B | A & B
--+---+------
0 | 0 |  0
0 | 1 |  0
1 | 0 |  0
1 | 1 |  1

ビットマスク 0x0f = 0000 1111 の意味:
- 上位4ビット: 0（マスクで消去）
- 下位4ビット: 1（そのまま残す）

これにより、下位4ビットだけを抽出できます。
```

#### 5. ペイロードの取得

ヘッダー長が分かれば、ペイロード（上位層のデータ）の開始位置も分かります。

```rust
pub fn payload(&self) -> &[u8] {
    let header_len = self.header_length();  // 例: 20
    &self.data[header_len..]  // 20バイト目以降がペイロード
}
```

具体例。

```text
パケット全体（40バイト）:

バイト位置:  0      ...     19 20      ...     39
           +---------------+-------------------+
           | IPv4ヘッダー  | ペイロード        |
           | (20バイト)    | (TCPセグメント等) |
           +---------------+-------------------+
                           ↑
                      header_len = 20
                      ペイロード開始位置

&self.data[20..] → ペイロードのスライス
```

#### 6. 右シフトとAND演算の使い分け

これまでに学んだビット演算をまとめましょう。

```text
バイト0: 0x45 = 0100 0101

上位4ビットを取得（バージョン）:
data[0] >> 4
= 0000 0100 = 4
→ 右シフトで上位ビットを移動

下位4ビットを取得（IHL）:
data[0] & 0x0f
= 0000 0101 = 5
→ ANDマスクで上位ビットを消去
```

どちらの方法もビットの抽出に使えますが、用途によって使い分けます。

- 右シフト（`>>`）: 上位ビットを取得する場合
- AND演算（`&`）: 下位ビットを取得する場合、または特定のビットパターンをチェックする場合

---

## Iteration 15: チェックサムを計算・検証

### チェックサム計算の実装

チェックサムは、ヘッダーの整合性を確認するための重要な仕組みです。

### Step 1: 関数のテストを書く（Red）

まず、`calculate_ipv4_checksum`関数が正しくチェックサムを計算できることをテストします。この関数は外部からも使用される可能性があるため、独立したユニットテストを作成します。

```rust
#[test]
fn チェックサムを計算できる() {
    let data = vec![
        0x45, 0x00, 0x00, 0x28, // Version, IHL, ToS, Total Length
        0x00, 0x00, 0x00, 0x00, // Identification, Flags, Fragment Offset
        0x40, 0x06, 0x00, 0x00, // TTL, Protocol, Checksum (0で初期化)
        0xc0, 0xa8, 0x01, 0x01, // Source IP
        0xc0, 0xa8, 0x01, 0x02, // Destination IP
    ];

    let checksum = calculate_ipv4_checksum(&data);
    // 正しいチェックサム値を検証
    assert_ne!(checksum, 0);
}
```

### Step 2-4: Red → Green

```rust
pub fn calculate_ipv4_checksum(header: &[u8]) -> u16 {
    let mut sum: u32 = 0;

    // 16ビットワードごとに加算
    for i in (0..header.len()).step_by(2) {
        let word = if i + 1 < header.len() {
            u16::from_be_bytes([header[i], header[i + 1]]) as u32
        } else {
            (header[i] as u32) << 8
        };
        sum += word;
    }

    // キャリーを折り返す
    while (sum >> 16) != 0 {
        sum = (sum & 0xffff) + (sum >> 16);
    }

    // 1の補数を取る
    !(sum as u16)
}
```

チェックサム計算には3つの重要なステップがあります。まず、ヘッダーを16ビットワード単位で加算します。次に、キャリーの折り返しを行います。これは16ビットを超えた部分を下位に加算する処理です。最後に、1の補数を取ります。これはビット反転（`!`演算子）で実現できます。

#### なぜこのコードを書くのか？

#### 1. チェックサムの目的

チェックサム（Checksum）は、データ転送中にエラーが発生していないかを検出するための仕組みです。ネットワーク上では、様々な原因でデータが破損する可能性があります。

- 電気的ノイズ
- ケーブルの不良
- ルーターの障害
- 無線通信の干渉

チェックサムがあることで、受信側は「このパケットは正しく届いたか？」を確認できます。

```text
送信側:
1. ヘッダーを作成（チェックサムフィールドは0）
2. チェックサムを計算
3. チェックサムフィールドに値を書き込む
4. パケット送信

受信側:
1. パケット受信
2. チェックサムを再計算
3. 再計算した値が0なら正常、0でなければエラー
```

#### 2. IPv4チェックサム計算の手順

IPv4のチェックサム計算は、RFC 791で定義されている特殊なアルゴリズムです。以下の手順で計算します。

#### ステップ1: チェックサムフィールドを0にする

```text
元のヘッダー（10-11バイト目がチェックサム）:
0x45 0x00 0x00 0x28 0x00 0x00 0x00 0x00 0x40 0x06 [??] [??] ...
                                                    ↑    ↑
                                            チェックサムを0に
↓
0x45 0x00 0x00 0x28 0x00 0x00 0x00 0x00 0x40 0x06 0x00 0x00 ...
```

#### ステップ2: 16ビット（2バイト）ワードごとに分割して加算

```rust
// 16ビットワードごとに加算
for i in (0..header.len()).step_by(2) {
    let word = u16::from_be_bytes([header[i], header[i + 1]]) as u32;
    sum += word;
}
```

具体例。

```text
ヘッダー（20バイト）:
0x45 0x00 | 0x00 0x28 | 0x00 0x00 | 0x00 0x00 | 0x40 0x06 |
0x00 0x00 | 0xc0 0xa8 | 0x01 0x01 | 0xc0 0xa8 | 0x01 0x02 |

16ビットワードに分割:
0x4500
0x0028
0x0000
0x0000
0x4006
0x0000  ← チェックサムフィールド（0）
0xc0a8
0x0101
0xc0a8
0x0102

加算:
0x4500 + 0x0028 + 0x0000 + 0x0000 + 0x4006 + 0x0000 +
0xc0a8 + 0x0101 + 0xc0a8 + 0x0102
= 0x18AD9 (32ビットの和)
```

#### ステップ3: キャリーの折り返し

32ビットの和を16ビットに収めるため、上位16ビット（キャリー）を下位16ビットに加算します。

```rust
// キャリーを折り返す
while (sum >> 16) != 0 {
    sum = (sum & 0xffff) + (sum >> 16);
}
```

具体例。

```text
sum = 0x18AD9

上位16ビット: 0x0001
下位16ビット: 0x8AD9

折り返し:
0x8AD9 + 0x0001 = 0x8ADA
```

#### ステップ4: 1の補数を取る

最後に、ビット反転（1の補数）を行います。

```rust
// 1の補数を取る
!(sum as u16)
```

具体例。

```text
sum = 0x8ADA

2進数表記:
1000 1010 1101 1010

1の補数（ビット反転）:
0111 0101 0010 0101

結果: 0x7525
```

これがチェックサム値です。

#### 3. 1の補数とは

1の補数（One's Complement）は、すべてのビットを反転する演算です。

```text
元の値:    1010 1100
1の補数:   0101 0011
           ↑↑↑↑ ↑↑↑↑
           すべて反転

Rustでの実装:
!value  // ビット反転演算子
```

2の補数との違い。

```text
元の値:     1010 1100 = 172 (符号なし)

1の補数:    0101 0011 = 83  (ビット反転)
2の補数:    0101 0100 = 84  (ビット反転 + 1)
```

IPv4チェックサムでは1の補数を使用します。

#### 4. チェックサム検証が0になる理由

送信側で計算したチェックサムをヘッダーに埋め込んだ場合、受信側で同じ計算を行うと結果が`0`になります。これは、チェックサムアルゴリズムの数学的な性質です。

```text
送信側:
1. ヘッダー（チェックサム0）: A, B, C, ..., 0, ...
2. 合計: sum = A + B + C + ...
3. チェックサム: checksum = ~sum
4. ヘッダーに埋め込み: A, B, C, ..., checksum, ...

受信側:
1. 合計: A + B + C + ... + checksum
2. = A + B + C + ... + ~sum
3. = sum + ~sum
4. = 0xFFFF (すべて1)
5. 1の補数: ~0xFFFF = 0x0000

結果が0なら正常！
```

実装コード。

```rust
pub fn verify_checksum(&self) -> bool {
    let header_len = self.header_length();
    let checksum = calculate_ipv4_checksum(&self.data[..header_len]);
    checksum == 0  // チェックサム含めて計算すると0になる
}
```

#### 5. 奇数長データの扱い

IPv4ヘッダーは通常4バイトの倍数ですが、一般的なチェックサム計算では奇数長のデータも扱えるようにします。

```rust
let word = if i + 1 < header.len() {
    u16::from_be_bytes([header[i], header[i + 1]]) as u32
} else {
    (header[i] as u32) << 8  // 最後の1バイトは上位バイトとして扱う
};
```

例。

```text
データ: [0xAA, 0xBB, 0xCC]  ← 3バイト（奇数）

16ビットワード化:
- ワード1: 0xAABB
- ワード2: 0xCC00 ← 最後の1バイトは上位に配置
```

この処理により、どのような長さのデータでもチェックサムを正しく計算できます。

### チェックサム検証の実装

次に、`Ipv4Packet`のメソッドとしてチェックサムを検証する機能を実装します。

```rust
impl<'a> Ipv4Packet<'a> {
    pub fn verify_checksum(&self) -> bool {
        let header_len = self.header_length();
        let checksum = calculate_ipv4_checksum(&self.data[..header_len]);
        checksum == 0 // チェックサム含めて計算すると0になる
    }
}
```

### チェックサム検証のテスト

`verify_checksum`メソッドの動作を確認するため、2つのテストケースを追加します。

#### 正しいチェックサムの検証

```rust
#[test]
fn 正しいチェックサムを持つパケットを検証できる() {
    // チェックサムフィールドを0で初期化したヘッダーを作成
    let mut data = vec![
        0x45, 0x00, 0x00, 0x28, // Version, IHL, ToS, Total Length
        0x00, 0x00, 0x00, 0x00, // Identification, Flags, Fragment Offset
        0x40, 0x06, 0x00, 0x00, // TTL, Protocol, Checksum (0で初期化)
        0xc0, 0xa8, 0x01, 0x01, // Source IP
        0xc0, 0xa8, 0x01, 0x02, // Destination IP
    ];

    // チェックサムを計算
    let checksum = calculate_ipv4_checksum(&data);

    // チェックサムフィールドに計算結果を埋め込む（10, 11バイト目）
    data[10] = (checksum >> 8) as u8;
    data[11] = (checksum & 0xff) as u8;

    // パケットを作成して検証
    let packet = Ipv4Packet::new(&data).unwrap();
    assert!(packet.verify_checksum());
}
```

このテストでは、正しいチェックサム値を持つパケットを作成し、`verify_checksum()`が`true`を返すことを確認します。重要なポイントは、チェックサムフィールドを含めて再計算すると結果が`0`になることです。

#### 不正なチェックサムの検証

```rust
#[test]
fn 不正なチェックサムを持つパケットを検証できる() {
    let data = vec![
        0x45, 0x00, 0x00, 0x28, // Version, IHL, ToS, Total Length
        0x00, 0x00, 0x00, 0x00, // Identification, Flags, Fragment Offset
        0x40, 0x06, 0xff, 0xff, // TTL, Protocol, Checksum (不正な値)
        0xc0, 0xa8, 0x01, 0x01, // Source IP
        0xc0, 0xa8, 0x01, 0x02, // Destination IP
    ];

    // パケットを作成して検証
    let packet = Ipv4Packet::new(&data).unwrap();
    assert!(!packet.verify_checksum());
}
```

このテストでは、不正なチェックサム値（`0xff, 0xff`）を持つパケットを作成し、`verify_checksum()`が`false`を返すことを確認します。

### テストの役割分担

- 関数のテスト（`チェックサムを計算できる`）: `calculate_ipv4_checksum`関数が独立して正しく動作することを検証
- メソッドのテスト（`正しいチェックサムを持つパケットを検証できる`、`不正なチェックサムを持つパケットを検証できる`）: `Ipv4Packet`のメソッドとして統合された状態での動作を検証

---

## Phase 3のまとめ

このフェーズでは、以下を学びました。

### IPv4の理解

IPv4プロトコルの重要な特徴を学びました。IPアドレスによる論理的なアドレッシングの仕組みを理解し、可変長ヘッダー（IHL）の扱い方を習得しました。また、プロトコル番号による上位層の識別方法と、チェックサムによる整合性確認の重要性を学びました。

### Rustの機能

Rustの低レベルプログラミングに必要な機能を習得しました。ビット演算（`>>`、`<<`、`&`）の使い方を学び、標準ライブラリの`Ipv4Addr`型を活用しました。また、`u16::from_be_bytes`による数値変換の方法も理解しました。

### TDDの実践

TDDで複雑なロジックを構築する方法を実践しました。チェックサムのような複雑な計算処理も、TDDで段階的に構築することで確実に実装できることを体験しました。また、テストが仕様を文書化する役割を果たすことを再確認しました。

---

## 次のステップ

Phase 3が完了しました！次は[Phase 4: TCPパケットパーサー](./phase4-tcp-packet.md)に進みましょう。

TCPはトランスポート層のプロトコルで、信頼性のあるデータ転送を実現します。接続確立（3-wayハンドシェイク）、フロー制御、再送制御など、より高度な機能を持っています。

---

## ナビゲーション

- 前へ：[Phase 2: Ethernetフレームパーサー](./phase2-ethernet-frame.md)
- 次へ：[Phase 4: TCPパケットパーサー](./phase4-tcp-packet.md)
- ホーム：[README](../README.md)
