# 現代WebフレームワークにおけるRPCとシリアライゼーションの構造的セキュリティリスクに関する包括的調査報告書

## エグゼクティブサマリー

Web開発のパラダイムは、かつてのRESTful APIによる疎結合なアーキテクチャから、クライアントとサーバーの境界を曖昧にする「メタフレームワーク」へと急速に移行しています。Next.js、SvelteKit、Nuxt、Remix、SolidStart、Qwik、Astroといった主要なフレームワークは、「Server Actions」や「Server Functions」と呼ばれるRPC（Remote Procedure Call）ライクな機能を導入し、開発者がクライアントサイドのコンポーネントからサーバーサイドの関数を直接呼び出せるような開発体験（DX）を提供しています。

この「シームレスな結合」を実現するために不可欠なのが、ネットワークの壁を越えて複雑なデータ構造（Promise、Date、Map、Set、さらにはリアクティブな状態やクロージャ）を運搬するための高度なシリアライゼーションプロトコルです。しかし、2025年末に発覚したNext.jsおよびReactにおける深刻なリモートコード実行（RCE）脆弱性「React2Shell」（CVE-2025-55182）は、これらのプロトコルが新たな攻撃対象領域（Attack Surface）となっていることを浮き彫りにしました[^1]。

本報告書は、Reactの「Flight」プロトコルにおける脆弱性を起点として、SvelteKitのdevalue、Remixのturbo-stream、NuxtのNitro/H3シリアライゼーション、AstroのActions API、そしてSolidJS/Qwikの独自メカニズムを網羅的に調査・分析したものです。調査の結果、各フレームワークが採用する「リッチデータ」シリアライゼーションのアプローチには、プロトタイプ汚染、オブジェクト注入、DoS（サービス拒否）攻撃といった共通の構造的リスクが内在していることが明らかになりました。特に、JSONの制約を超えようとする試みが、皮肉にもセキュリティの境界を脆弱にしている現状を詳らかにします。

---

## 第1章 Webアーキテクチャの変遷とRPCの回帰

### 1.1 分離から融合へ:ネットワーク境界の消失

Webアプリケーションのアーキテクチャは、過去10年間で劇的な変化を遂げました。かつて主流であった「SPA（Single Page Application）+ REST API」モデルでは、フロントエンドとバックエンドは明確に分離されており、通信はJSON（JavaScript Object Notation）という、データ表現に特化したシンプルかつ制約の多いフォーマットで行われていました。この「制約」こそが、セキュリティ上の防壁として機能していました。JSONは関数やクラスインスタンス、循環参照を表現できないため、攻撃者が悪意あるコードや複雑なオブジェクトグラフを注入する余地が限られていたのです。

しかし、現代のメタフレームワークは、この分離を取り払う方向へ進化しています。Next.jsのServer ActionsやSvelteKitのForm Actions、RemixのSingle Fetchといった機能は、サーバーサイドのロジックをクライアントサイドのコードの一部として記述することを可能にします[^3]。これにより、開発者はAPIエンドポイントの定義や型定義の重複といった「ボイラープレート」から解放されましたが、同時にクライアントとサーバーの間にあるべき「不信の境界線」が視覚的・心理的に希薄化しました。

### 1.2 「リッチデータ」シリアライゼーションの必然性

この新しいパラダイムにおいて、標準的なJSON.stringifyとJSON.parseは機能不足となりました。開発者は、サーバーで取得したDateオブジェクトがクライアントで文字列になったり、Setが配列に変換されたり、Promiseが消失したりすることを嫌いました。シームレスなRPC体験には、JavaScriptのメモリ空間にあるオブジェクトを、型や状態を維持したままネットワーク越しに再構築する技術が必要です。

これに応える形で、各フレームワークは独自の、あるいは拡張されたシリアライゼーションライブラリを採用しました。

- React/Next.js: React Flight Protocol（ストリーミング対応、React要素やPromiseの転送）[^4]
- SvelteKit/Nuxt: devalue（循環参照、Map/Set、BigIntなどのサポート）[^5]
- Remix: turbo-stream（Promiseのストリーミング、Error、Symbolのサポート）[^7]
- Astro: 入力検証を前提としたdevalueの利用[^9]
- Qwik/Solid: クロージャや実行コンテキストのシリアライゼーション[^10]

### 1.3 構造的リスクの発生源

セキュリティの観点から見ると、これらのライブラリは単なるデータ変換器ではなく、一種の「インタプリタ」として振る舞います。信頼できないクライアントからの入力を解析し、サーバー上のメモリ空間に複雑なオブジェクトグラフを復元するプロセスは、JavaやPHPで過去に流行した「安全でないデシリアライゼーション（Insecure Deserialization）」脆弱性の現代版といえます。攻撃者は、この復元プロセスを悪用し、本来アクセスできないはずのプロトタイプチェーンの操作や、内部モジュールの強制的な読み込み、あるいはメモリ枯渇を引き起こすことが可能になります。

---

## 第2章 React/Next.js RCE事例（React2Shell）の解剖

他のフレームワークのリスクを評価するためのベースラインとして、CVE-2025-55182（通称React2Shell）のメカニズムを詳細に分析します。この事例は、プロトコルレベルの欠陥がいかにしてフレームワーク全体のセキュリティを崩壊させるかを示す教訓的なケースです。

### 2.1 React Flightプロトコルの特殊性

React Server Components（RSC）は、「Flight」と呼ばれる独自のアスキーベースのストリーミングプロトコルを使用します。これはUIツリーを表現するために設計されましたが、Server Actions（クライアントからサーバーへの関数呼び出し）の引数をシリアライズするためにも使用されます。

このプロトコルの特徴は、データを「チャンク（Chunk）」に分割し、相互参照を可能にすることです。

```text
0: ["$@1", "$@2"]
1: {"action": "update", "data": "$@3"}
3: {"name": "Alice"}
```

このように、$@というプレフィックスを用いて、後続の行で定義されるデータを参照します[^4]。

### 2.2 攻撃のメカニズム:強制的なモジュール解決

CVE-2025-55182の本質は、デシリアライザー（復元器）がクライアントからの指示を過度に信頼していた点にあります。

1. チャンクの偽装: 攻撃者は、通常のデータ構造に見せかけて、React内部で使用される特殊なマーカー（例えば、遅延ロードされるモジュールやPromiseを示す識別子）を含むペイロードを作成します。
2. プロトタイプ汚染とメソッドオーバーライド: ペイロード内でObject.prototypeやPromise.prototypeに干渉するような定義を紛れ込ませることで、サーバー側での処理ロジックを歪めます。具体的には、thenメソッドをオーバーライドすることで、Promiseの解決プロセスをハイジャックし、任意のコード実行へと誘導するガジェットチェーンが形成されました[^11]。
3. モジュールローダーの悪用: デシリアライザーが「モジュール参照」として解釈するデータを送り込むことで、サーバーのファイルシステム上にある任意のモジュール（本来は公開されていない内部ユーティリティなど）をrequire/importさせることが可能でした。これにより、RCEの足掛かりとなるガジェットへのアクセスが可能になりました[^2]。

### 2.3 認証前RCEという衝撃

この脆弱性が「CVSS 10.0」と評価された理由は、認証を必要としない点にあります。Next.jsアプリケーションがデフォルトで公開しているServer Actionsのエンドポイントに対して、特定の形式のPOSTリクエストを送信するだけで攻撃が成立しました[^13]。これは、アプリケーション開発者がどれほど堅牢な認証ロジックを実装していても、フレームワークの層で防御が突破されることを意味します。

---

## 第3章 SvelteKitとdevalue:循環参照の代償

SvelteKitは、データロードやフォームアクションにおいて、Rich Harris氏が開発したdevalue（およびuneval）ライブラリを採用しています。これはJSON.stringifyよりも強力で、evalよりも安全であることを目指したライブラリですが、構造的なリスクを抱えています。

### 3.1 devalueのアーキテクチャとプロトタイプ汚染

devalueは、循環参照を含む複雑なオブジェクトグラフをシリアライズするために、フラットな配列表現とインデックス参照を使用します。この構造自体は効率的ですが、復元（Parse）のロジックに落とし穴がありました。

CVE-2025-57820の分析: 2025年初頭に報告されたdevalueの脆弱性は、古典的なプロトタイプ汚染でした[^14]。

- 攻撃手法: 攻撃者は、devalue.parseに渡される文字列を操作し、オブジェクトのキーとして__proto__を指定するような構造を作成します。devalueはオブジェクトを復元する際、キーのバリデーションを十分に行わずにプロパティを代入していました。
- 影響: これにより、サーバー上で稼働しているアプリケーション全体のObject.prototypeが汚染されます。Node.js環境では、プロトタイプ汚染は容易にRCE（例えば、child_process.spawnのオプション汚染など）につながることが知られています[^16]。

### 3.2 SvelteKitにおける攻撃経路

SvelteKitは、標準的なフォーム送信（`<form method="POST">`）ではFormDataを使用するため、この経路は比較的安全です[^18]。FormDataは文字列とファイルのみを扱い、複雑なオブジェクト構造を持たないため、プロトタイプ汚染のリスクが極めて低いからです。

しかし、リスクは以下の2点に潜んでいます。

1. Superformsなどのエコシステム: sveltekit-superformsのような人気ライブラリは、クライアント・サーバー間でリッチな型安全性を提供するために、リクエストボディのシリアライゼーションにdevalueを使用するオプションや推奨パターンを持っています[^10]。開発者が「便利だから」という理由でdevalueによるRPCパターンを採用した瞬間、アプリケーションはNext.jsと同様のリスクに晒されます。
2. カスタムAPIエンドポイント: 開発者が+server.tsでJSON以外のリッチデータを受け取るために手動でdevalue.parse(requestBody)を実装した場合、そのエンドポイントは即座に脆弱となります[^20]。

比較分析: Next.jsが「デフォルトで危険（Flightプロトコルを強制）」であるのに対し、SvelteKitは「デフォルトは安全（FormData）だが、拡張すると危険」という位置づけになります。しかし、コミュニティがリッチなRPC体験を求めてdevalueの利用を拡大している現状[^19]は、潜在的なリスクを高めています。

---

## 第4章 Remixとturbo-stream:ストリーミングとPromiseの罠

Remix（およびReact Router v7）は、「Single Fetch」と呼ばれる新しいデータロード戦略を導入しました。この基盤となるのがturbo-streamライブラリです。これはdevalueの派生ですが、ストリーミングとPromiseのサポートに特化しています。

### 4.1 turbo-streamの機能と構造

turbo-streamは、サーバーからのレスポンスが完了するのを待たずに、データの断片を順次クライアントに送信することを可能にします。特筆すべきは、Promiseのシリアライゼーションです。サーバー側で未解決のPromiseがある場合、プレースホルダーを先に送信し、解決した時点でその値を後追い（out-of-order）でストリームします[^7]。

サポートされる型は広範で、BigInt、Date、Error、Map、Set、URL、そしてPromiseが含まれます[^7]。

### 4.2 構造的リスク分析

#### 4.2.1 Promise注入によるDoS（サービス拒否）

もしRemixが、クライアントからサーバーへのリクエスト（Action引数など）にturbo-streamを使用する場合、深刻なDoSリスクが生じます。

- 攻撃シナリオ: 攻撃者は、解決されない「Pending状態のPromise」を大量に含むペイロード、あるいは深くネストされたPromiseチェーンを表現するストリームを送信します。
- サーバーの挙動: サーバー側のデシリアライザーは、これらのPromiseをメモリ上に展開し、解決を待ち続けます。適切なタイムアウトや深さ制限がない場合、攻撃者は少量のデータでサーバーのメモリリソースやファイルディスクリプタを枯渇させることができます（非対称リソース消費攻撃）[^21]。
- 現状: Remixのturbo-streamは主にサーバー→クライアント（Loaderの戻り値）で使用されていますが、Resource Routesやカスタム実装で双方向通信に利用しようとする動き[^7]があり、この誤用がセキュリティホールとなります。

#### 4.2.2 「裸のオブジェクト（Naked Object）」による情報漏洩

RemixのSingle Fetchでは、json()ヘルパーを使わずに生のオブジェクトをreturnできるようになりました（Naked Object Return）[^7]。

- 従来: json(data)を使用すると、JSON.stringifyが走るため、シリアライズ不可能な内部オブジェクト（例えば、データベース接続を持つORMのインスタンスや、循環参照を含む内部クラス）が含まれているとエラーになり、開発者は気づくことができました。
- 現在: turbo-streamは強力なため、これらの内部オブジェクトも可能な限りシリアライズしようと試みます。開発者が意図せずバックエンドの内部構造（プライベートフィールドや、サーバーのファイルパスを含むエラーオブジェクトなど）をクライアントに送信してしまう「過剰なデータ露出（Excessive Data Exposure）」のリスクが高まります[^23]。

#### 4.2.3 エラーオブジェクトのデシリアライズ

turbo-streamはErrorオブジェクトとそのサブタイプをサポートしています[^7]。攻撃者がサーバーに対してErrorオブジェクトを含むペイロードを送信し、それをログ出力させることができれば、スタックトレースの偽装によるログ汚染や、エラーハンドリングロジックの撹乱が可能になります。また、Errorオブジェクトのプロパティ（nameやmessage以外に付加されたカスタムプロパティ）を通じたプロトタイプ汚染の可能性も否定できません。

---

## 第5章 Nuxt (Vue) とNitro:ハイブリッドアプローチの死角

Nuxt 3は、サーバーエンジンNitroとHTTPフレームワークH3の上に構築されています。シリアライゼーションに関しては、ハイドレーション（サーバー→クライアント）にはdevalueを使用し、API通信にはJSONを基本とするハイブリッドなアプローチをとっています。

### 5.1 「Rich JSON」ペイロードとカスタムReviverのリスク

Nuxtは、useFetchなどでDateやRegExpなどの型をサポートするために、「Rich JSON」ペイロードシステムを導入しました[^24]。これは、JSONの中に型情報を含め、クライアント側で「Reviver（復元関数）」を通してオブジェクトに戻す仕組みです。

攻撃の兆候: 調査の中で、Nuxtのエコシステムにおいて「クラスインスタンス」を転送したいという需要に対し、開発者が危険なプラグインを実装している事例が確認されました[^24]。

```javascript
// 脆弱な実装例（概念図）
definePayloadReviver('MyClass', (data) => {
  const ClassRef = globalContext[data.className]; // 危険:文字列からクラスを動的参照
  return new ClassRef(data.args);
});
```

このようなカスタムReviverが実装された場合、攻撃者はペイロード内のクラス名を操作することで、サーバー（またはクライアント）のコンテキストに存在する任意のクラスをインスタンス化できる「オブジェクト注入（Object Injection）」脆弱性を生み出します。PHPやJavaで頻発した脆弱性が、JavaScriptのメタフレームワーク上で再現される形となります。

### 5.2 実験的Server FunctionsとRPC

Nuxtもまた、ReactやSolidと同様のRPC機能（Server Functions）を実験的に導入しています[^26]。

- 現状: デフォルトではJSONベースですが、引数の型安全性（Rich Types）を求める声が強く、今後devalueや独自のシリアライザーが採用される可能性があります。
- リスク: Next.jsがFlightプロトコルで躓いたように、NuxtがRPC引数のために「何でもシリアライズできる」プロトコルを採用すれば、即座にプロトタイプ汚染やモジュール解決攻撃の対象となります。特に、Nitro/H3層でのバリデーションがJSONスキーマ等で厳格に行われない限り、このリスクは排除できません。

### 5.3 Nuxt Island Components

サーバーサイドのみでレンダリングされる「Island Components」は、サーバーへのリクエストとしてコンポーネントのPropsを送信します[^27]。

- 類似性: このメカニズムはReact Server Componentsと酷似しています。もしクライアントが送信するPropsのペイロードに、サーバー上のファイルパスやモジュールIDを指定できるような構造が含まれている場合、React2Shellと同様のローカルファイルインクルード（LFI）やRCEにつながる恐れがあります[^11]。

---

## 第6章 Astro Actions:検証ファーストによる防御

Astroはバージョン4.15で「Astro Actions」を導入しました。他のフレームワークと比較して、Astroのアプローチはセキュリティ設計において一線を画しています。

### 6.1 バリデーションの強制（Zod Integration）

Astro Actionsの最大の特徴は、アクション定義時に入力バリデーションスキーマ（Zod）の定義を強制する点です[^9]。

```typescript
export const server = {
  updateUser: defineAction({
    input: z.object({ // スキーマ定義が必須
      userId: z.string(),
      email: z.string().email(),
    }),
    handler: async (input, context) => {
      // inputは既に検証・型変換済み
    }
  })
}
```

### 6.2 セキュリティ上の優位性

この「検証ファースト」アーキテクチャは、シリアライゼーション攻撃に対する強力な防御壁となります。

1. 構造的フィルタリング: Zodスキーマは、許可されたフィールド以外を削除（strip）するか、リクエストを拒否します。Reactの脆弱性で悪用されたような$@プレフィックス付きの隠しプロパティや、SvelteKitで問題となる__proto__プロパティは、スキーマに含まれていない限りハンドラーに到達する前に破棄されます[^29]。
2. デシリアライズの分離: Astroは、リクエストボディ（JSONまたはFormData）を標準的なパーサーで解析した後、Zodに通します。ハンドラーは「生のデシリアライズ結果」ではなく「検証済みのデータ」のみを受け取るため、オブジェクトグラフを盲目的に信頼することによる脆弱性が極小化されます。

### 6.3 残留リスク

唯一の懸念点は、AstroがZodによる検証を行う前の段階、つまり生のHTTPボディをパースする段階です。もしAstroが将来的に、JSON以外のリッチデータ（DateやMapなど）を入力として受け入れるために、生のボディに対してdevalue.parseのようなリッチパーサーを適用するようになれば、Zodに到達する前にプロトタイプ汚染が発生する可能性があります[^30]。しかし、現状のドキュメントでは標準的なJSON/FormDataの使用が前提となっており、このリスクは低く抑えられています。

---

## 第7章 SolidJSとQwik:クロージャと実行パスのシリアライズ

SolidJSとQwikは、他のフレームワークとは異なるユニークな実行モデルを持っており、それに伴う特有のリスクが存在します。

### 7.1 Qwik:QRLと実行パスの署名

Qwikの「Resumability（再開可能性）」は、イベントハンドラなどの関数を「QRL（Qwik URL）」としてシリアライズし、HTML内に埋め込むことで実現されます[^10]。

- QRLの例: `<button on:click="./chunk-abc.js#handler">`
- 攻撃ベクトル（関数ハイジャック）: 攻撃者がDOM内のQRLを書き換え、`./chunk-admin.js#deleteDatabase`のような本来アクセス権のない関数を指すように改ざんした場合、ユーザーのクリックによって意図しないサーバー処理を実行させることが可能です。
- 防御策: Qwikはこのリスクを認識しており、ビルド時に生成されたQRLに対して暗号学的ハッシュ（署名）を付与し、実行時に検証する仕組みを持っています。
- リスク: 開発モードや、設定ミスによりこの署名検証が無効化されている場合、あるいは署名生成の秘密鍵が漏洩した場合、RCEは極めて容易になります。

### 7.2 SolidStart:クロージャのシリアライズ

SolidStartのserver$関数は、クライアントサイドで定義されたクロージャをサーバーで実行する機能です。

```javascript
const userId = 123;
const getUser = server$(() => db.get(userId)); // userId変数をキャプチャ
```

このコードが機能するためには、userIdという変数の値をシリアライズしてサーバーに送信する必要があります。

- 状態の改ざん: クライアントは、シリアライズされたクロージャの状態（userId=123）を保持しています。攻撃者がこの値を456に書き換えて送信した場合、サーバーは他人のデータを取得してしまいます。
- 対策: SolidJSもまた、シリアライズされたスコープ変数に対して暗号化や署名を行う必要があります。React Server Actionsが「クロージャの引数」を自動的に暗号化するように、SolidStartも同様の機構を不可視に行う必要がありますが、その実装の堅牢性がセキュリティの生命線となります。

---

## 第8章 比較分析とリスク評価マトリクス

以上の調査に基づき、各フレームワークのサーバーアクションおよびRPC機能における構造的セキュリティリスクを比較評価しました。

### 表1:構造的セキュリティリスクの比較分析

| フレームワーク | RPC/Actionメカニズム | シリアライゼーションプロトコル | 入力検証の強制 | クライアント→サーバー（入力）の脆弱性プロファイル | リスクレベル |
| :---- | :---- | :---- | :---- | :---- | :---- |
| Next.js | Server Actions | React Flight | なし (開発者依存) | Critical: 複雑なオブジェクトグラフ、モジュール参照、Promiseをネイティブにサポートするため、オブジェクト注入・RCEのリスクが構造的に高い（CVE-2025-55182）。 | Critical |
| SvelteKit | Form Actions / Load | devalue (拡張利用時) | なし (開発者依存) | High: devalue自体にプロトタイプ汚染の脆弱性あり（CVE-2025-57820）。標準のFormDataは安全だが、リッチRPCへの拡張時にリスクが急増する。 | High |
| Remix | Single Fetch / Actions | turbo-stream | なし (開発者依存) | High: Promise注入によるDoS、内部情報の漏洩リスク。プロトコルが不透明であり、セキュリティ監査が困難。 | High |
| Nuxt | Server Routes / RPC | JSON (デフォルト) / Custom | なし (開発者依存) | Medium: デフォルトはJSONで安全寄りだが、カスタムReviverによるオブジェクト注入リスクや、実験的RPCの採用によるリスク増大の懸念あり。 | Medium |
| Qwik | server$ / QRL | QRL (シリアライズされた参照) | 署名による保護 | Medium: 署名メカニズムに依存。設定ミスや署名バイパスが即RCEに直結する。 | Medium |
| Astro | Astro Actions | JSON / FormData | Zodスキーマ必須 | Low: フレームワークレベルで型と値の検証を強制するため、不正なシリアライズデータがハンドラーに到達しにくい。 | Low |

### 8.1 「DX（開発体験）とセキュリティ」のトレードオフ曲線

分析から明らかになったのは、「魔法のようなDX」と「セキュリティリスク」の強い相関関係です。

- High Magic (Next.js, Remix): 「DateもPromiseもそのまま渡せる」という体験を優先するため、裏側で極めて複雑なデシリアライザーを稼働させています。これが攻撃の温床となります。
- Low Magic (Astro, Legacy Nuxt): 「入力は検証しなければならない」「データはJSONかFormDataに限る」という制約を課すことで、攻撃対象領域を大幅に縮小しています。

React/Next.jsのRCE事例は、この「魔法」を支えるFlightプロトコルが、信頼できないクライアントからの入力に対してあまりにも寛容すぎた（モジュール解決まで許容してしまった）結果と言えます。

---

## 第9章 結論と推奨される緩和策

### 9.1 結論:カスタムプロトコルは「新たなeval」である

本調査の結論として、React2Shell脆弱性は単発のバグではなく、現代のWebフレームワークが共通して抱える構造的な欠陥の一端であることが示されました。devalue、turbo-stream、Flightといったカスタムシリアライゼーションプロトコルは、実質的に「新たなeval」として機能しており、その入力値に対する検証が不十分な場合、アプリケーション全体を危険に晒します。

SvelteKitやRemixは、Reactほど複雑なモジュール解決機能を持たないため、直ちに同等のRCEが発生するわけではありませんが、プロトタイプ汚染やDoSといった深刻なリスクを抱えています。唯一、Astroのみが「検証ファースト」の設計によって、この構造的リスクを効果的に封じ込めています。

### 9.2 開発者および組織への推奨事項

1. 「裸のシリアライゼーション」を避ける:
   - Next.jsのServer ActionsやRemixのActionにおいて、フレームワークが提供する自動シリアライゼーション（DateやMapの直接受け渡し）に過度に依存せず、可能な限りプリミティブな型（文字列、数値、単純なオブジェクト）でやり取りすることを推奨します。

2. 入力検証の徹底（Astroパターンの採用）:
   - どのフレームワークを使用していても、サーバーサイドの関数の冒頭で必ずZod、Valibot、ArkTypeなどのスキーマバリデーションライブラリを使用し、入力データの「形（Shape）」を厳格に検証してください。
   - 例: `const cleanData = userSchema.parse(rawData);`
   - これにより、プロトタイプ汚染攻撃に含まれる__proto__などの不正なキーを確実に排除できます。

3. シリアライザーの利用制限:
   - SvelteKitやNuxtにおいて、リクエストボディのパースに手動でdevalue.parseを使用することは避けてください。どうしても必要な場合は、入力文字列の長さ制限や、プロトタイプを持たないオブジェクト（Object.create(null)）への展開などの対策が必要です。

4. WAF（Web Application Firewall）の設定:
   - React Flightプロトコル特有のマーカー（$@）や、プロトタイプ汚染のシグネチャ（__proto__、constructor）を含むリクエストボディを、アプリケーション層に到達する前にブロックするルールの導入を検討してください[^31]。

5. 監視とパッチ適用:
   - react-server-dom-*、devalue、turbo-streamなどのライブラリは現在、セキュリティ研究者の集中的な監査対象となっています。これらのパッケージの更新情報には常に注意を払い、リリースされ次第即座に適用する体制を整えてください。

Web開発の未来はRPCへと向かっていますが、その安全性は「見えない通信層」をいかに厳格に管理するかにかかっています。開発者は「シームレス」という幻想の裏にあるリスクを直視し、明示的な防御策を講じる必要があります。

#### 引用文献

[^1]: Critical Remote Code Execution (RCE) Vulnerabilities in React and Next.js - Endor Labs, 12月 12, 2025にアクセス、 <https://www.endorlabs.com/learn/critical-remote-code-execution-rce-vulnerabilities-in-react-and-next-js>
[^2]: Exploitation of Critical Vulnerability in React Server Components (Updated December 11), 12月 12, 2025にアクセス、 <https://unit42.paloaltonetworks.com/cve-2025-55182-react-and-cve-2025-66478-next/>
[^3]: SvelteKit RPC with Hono - DEV Community, 12月 12, 2025にアクセス、 <https://dev.to/tolu/sveltekit-rpc-with-hono-mje>
[^4]: CVE-2025-55182: React2Shell Analysis, Proof-of-Concept Chaos, and In-the-Wild Exploitation - Trend Micro, 12月 12, 2025にアクセス、 <https://www.trendmicro.com/en_us/research/25/l/CVE-2025-55182-analysis-poc-itw.html>
[^5]: sveltejs/devalue: Gets the job done when JSON.stringify can't - GitHub, 12月 12, 2025にアクセス、 <https://github.com/sveltejs/devalue>
[^7]: Single Fetch - Remix, 12月 12, 2025にアクセス、 <https://v2.remix.run/docs/guides/single-fetch/>
[^9]: Actions API Reference - Astro Docs, 12月 12, 2025にアクセス、 <https://docs.astro.build/en/reference/modules/astro-actions/>
[^10]: SvelteKit lacks "real" RPC-like server functions, compare Solid Start, TanStack Start (React) and Qwik City · Issue #13365 · sveltejs/kit - GitHub, 12月 12, 2025にアクセス、 <https://github.com/sveltejs/kit/issues/13365>
[^11]: How can unsafe React Server Component deserialization paths like those exploited in React2Shell (CVE-2025-55182) be reliably detected and secured? - Stack Overflow, 12月 12, 2025にアクセス、 <https://stackoverflow.com/questions/79840547/how-can-unsafe-react-server-component-deserialization-paths-like-those-exploited>
[^13]: Critical Security Vulnerability in React Server Components, 12月 12, 2025にアクセス、 <https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components>
[^14]: prototype pollution - CVE: Common Vulnerabilities and Exposures, 12月 12, 2025にアクセス、 <https://www.cve.org/CVERecord/SearchResults?query=prototype+pollution>
[^16]: Server-side prototype pollution | Web Security Academy - PortSwigger, 12月 12, 2025にアクセス、 <https://portswigger.net/web-security/prototype-pollution/server-side>
[^18]: SvelteKit Form Actions, where are my security flaws? - sveltejs - Reddit, 12月 12, 2025にアクセス、 <https://www.reddit.com/r/sveltejs/comments/1cfarxy/sveltekit_form_actions_where_are_my_security_flaws/>
[^19]: Allow the serialisation/deserialisation of non-POJOs · Issue #9401 · sveltejs/kit - GitHub, 12月 12, 2025にアクセス、 <https://github.com/sveltejs/kit/issues/9401>
[^20]: Sveltekit Actions returns garbled json - Stack Overflow, 12月 12, 2025にアクセス、 <https://stackoverflow.com/questions/74966175/sveltekit-actions-returns-garbled-json>
[^21]: Book of Abstracts - Indico Global, 12月 12, 2025にアクセス、 <https://indico.global/event/6793/attachments/28256/49018/20th_Real_Time_Conference_-_Book_of_abstracts.pdf>
[^23]: Use Blitz.js superjson instead of native JSON.serialize/parse · remix-run remix · Discussion #1910 · GitHub, 12月 12, 2025にアクセス、 <https://github.com/remix-run/remix/discussions/1910>
[^24]: Nuxt 3 rich JSON payload serialisation - Stack Overflow, 12月 12, 2025にアクセス、 <https://stackoverflow.com/questions/76588499/nuxt-3-rich-json-payload-serialisation>
[^26]: RPCs / server$ · nuxt nuxt · Discussion #20366 - GitHub, 12月 12, 2025にアクセス、 <https://github.com/nuxt/nuxt/discussions/20366>
[^27]: llms-full.txt - Nuxt, 12月 12, 2025にアクセス、 <https://nuxt.com/llms-full.txt>
[^29]: Actions - Astro Docs, 12月 12, 2025にアクセス、 <https://docs.astro.build/en/guides/actions/>
[^30]: Vulnerability Summary for the Week of August 25, 2025 | CISA, 12月 12, 2025にアクセス、 <https://www.cisa.gov/news-events/bulletins/sb25-245>
[^31]: Protect Against Critical RCE in React CVE-2025-5518 with Traceable WAF | Blog - Harness, 12月 12, 2025にアクセス、 <https://www.harness.io/blog/protect-against-critical-unauthenticated-rce-in-react-next-js-cve-2025-55182-with-traceable-waf>
