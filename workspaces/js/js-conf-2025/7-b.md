# JavaScriptにおけるasync/await呼び出しのスタックトレースの困難と実装

## メモ

同期

```js
function foo() {
  bar();
}
function bar() {
  throw new Error("oops");
}
foo(); // foo(),bar()がスタックトレースに乗る
```

非同期

```js
async function foo() {
  await bar();
}
async function bar() {
  await p: // Promise
  throw new Error("oops");
}
foo(); // bar()がスタックトレースに乗る
```

`Promise`が`resolve()`された時点で`bar()`の残り部分がマイクロタスクとしてスケジューラに登録される。
よって、`foo()`の責務が終わった後に別で実行されるのでスタックトレースに乗らない。

`async foo()`を戻り値に返す関数`bar()`があるとして、`return await foo();` vs `return foo();`の答えとしては、awaitした方が良い。スタックトレースが生成できないので。
